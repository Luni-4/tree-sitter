#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case,
         non_upper_case_globals, unused_assignments, unused_mut)]
#![register_tool(c2rust)]
#![feature(const_raw_ptr_to_usize_cast, extern_types, label_break_value,
           ptr_wrapping_offset_from, register_tool)]
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type TSTree;
    #[no_mangle]
    static mut stderr: *mut FILE;
    #[no_mangle]
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    #[no_mangle]
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn free(__ptr: *mut libc::c_void);
    #[no_mangle]
    fn exit(_: libc::c_int) -> !;
    /* *
 * Get the numerical id for the given field name string.
 */
    /* *
 * Check whether the given node type id belongs to named nodes, anonymous nodes,
 * or a hidden nodes.
 *
 * See also `ts_node_is_named`. Hidden nodes are never returned from the API.
 */
    /* *
 * Get the ABI version number for this language. This version number is used
 * to ensure that languages were generated by a compatible version of
 * Tree-sitter.
 *
 * See also `ts_parser_set_language`.
 */
    #[no_mangle]
    fn ts_language_version(_: *const TSLanguage) -> uint32_t;
    #[no_mangle]
    fn ts_language_symbol_count(_: *const TSLanguage) -> uint32_t;
    #[no_mangle]
    fn ts_language_symbol_type(_: *const TSLanguage, _: TSSymbol)
     -> TSSymbolType;
    #[no_mangle]
    fn ts_language_symbol_name(_: *const TSLanguage, _: TSSymbol)
     -> *const libc::c_char;
    #[no_mangle]
    fn ts_language_symbol_for_name(self_0: *const TSLanguage,
                                   string: *const libc::c_char,
                                   length: uint32_t, is_named: bool)
     -> TSSymbol;
    #[no_mangle]
    fn ts_language_field_id_for_name(_: *const TSLanguage,
                                     _: *const libc::c_char, _: uint32_t)
     -> TSFieldId;
    #[no_mangle]
    fn ts_tree_cursor_goto_first_child(_: *mut TSTreeCursor) -> bool;
    #[no_mangle]
    fn ts_tree_cursor_goto_next_sibling(_: *mut TSTreeCursor) -> bool;
    #[no_mangle]
    fn ts_node_symbol(_: TSNode) -> TSSymbol;
    #[no_mangle]
    fn ts_node_start_byte(_: TSNode) -> uint32_t;
    #[no_mangle]
    fn ts_node_start_point(_: TSNode) -> TSPoint;
    #[no_mangle]
    fn ts_node_end_byte(_: TSNode) -> uint32_t;
    #[no_mangle]
    fn ts_node_end_point(_: TSNode) -> TSPoint;
    #[no_mangle]
    fn ts_node_is_named(_: TSNode) -> bool;
    #[no_mangle]
    fn ts_tree_cursor_delete(_: *mut TSTreeCursor);
    #[no_mangle]
    fn ts_tree_cursor_reset(_: *mut TSTreeCursor, _: TSNode);
    #[no_mangle]
    fn ts_tree_cursor_current_node(_: *const TSTreeCursor) -> TSNode;
    #[no_mangle]
    fn ts_tree_cursor_goto_parent(_: *mut TSTreeCursor) -> bool;
    #[no_mangle]
    fn memcpy(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_ulong)
     -> *mut libc::c_void;
    #[no_mangle]
    fn memmove(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_ulong)
     -> *mut libc::c_void;
    #[no_mangle]
    fn memset(_: *mut libc::c_void, _: libc::c_int, _: libc::c_ulong)
     -> *mut libc::c_void;
    #[no_mangle]
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    #[no_mangle]
    fn strncmp(_: *const libc::c_char, _: *const libc::c_char,
               _: libc::c_ulong) -> libc::c_int;
    #[no_mangle]
    fn __assert_fail(__assertion: *const libc::c_char,
                     __file: *const libc::c_char, __line: libc::c_uint,
                     __function: *const libc::c_char) -> !;
    #[no_mangle]
    fn ts_tree_cursor_current_status(_: *const TSTreeCursor, _: *mut bool,
                                     _: *mut bool) -> TSFieldId;
    #[no_mangle]
    fn iswalnum(__wc: wint_t) -> libc::c_int;
    #[no_mangle]
    fn iswspace(__wc: wint_t) -> libc::c_int;
}
pub type size_t = libc::c_ulong;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type int16_t = __int16_t;
pub type int32_t = __int32_t;
pub type uint8_t = __uint8_t;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
/* ***************************/
/* Section - ABI Versioning */
/* ***************************/
/* *
 * The latest ABI version that is supported by the current version of the
 * library. When Languages are generated by the Tree-sitter CLI, they are
 * assigned an ABI version number that corresponds to the current CLI version.
 * The Tree-sitter library is generally backwards-compatible with languages
 * generated using older CLI versions, but is not forwards-compatible.
 */
/* *
 * The earliest ABI version that is supported by the current version of the
 * library.
 */
/* ******************/
/* Section - Types */
/* ******************/
pub type TSSymbol = uint16_t;
pub type TSFieldId = uint16_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSLanguage {
    pub version: uint32_t,
    pub symbol_count: uint32_t,
    pub alias_count: uint32_t,
    pub token_count: uint32_t,
    pub external_token_count: uint32_t,
    pub symbol_names: *mut *const libc::c_char,
    pub symbol_metadata: *const TSSymbolMetadata,
    pub parse_table: *const uint16_t,
    pub parse_actions: *const TSParseActionEntry,
    pub lex_modes: *const TSLexMode,
    pub alias_sequences: *const TSSymbol,
    pub max_alias_sequence_length: uint16_t,
    pub lex_fn: Option<unsafe extern "C" fn(_: *mut TSLexer, _: TSStateId)
                           -> bool>,
    pub keyword_lex_fn: Option<unsafe extern "C" fn(_: *mut TSLexer,
                                                    _: TSStateId) -> bool>,
    pub keyword_capture_token: TSSymbol,
    pub external_scanner: C2RustUnnamed,
    pub field_count: uint32_t,
    pub field_map_slices: *const TSFieldMapSlice,
    pub field_map_entries: *const TSFieldMapEntry,
    pub field_names: *mut *const libc::c_char,
    pub large_state_count: uint32_t,
    pub small_parse_table: *const uint16_t,
    pub small_parse_table_map: *const uint32_t,
    pub public_symbol_map: *const TSSymbol,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSFieldMapEntry {
    pub field_id: TSFieldId,
    pub child_index: uint8_t,
    pub inherited: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSFieldMapSlice {
    pub index: uint16_t,
    pub length: uint16_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed {
    pub states: *const bool,
    pub symbol_map: *const TSSymbol,
    pub create: Option<unsafe extern "C" fn() -> *mut libc::c_void>,
    pub destroy: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
    pub scan: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                          _: *mut TSLexer, _: *const bool)
                         -> bool>,
    pub serialize: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                               _: *mut libc::c_char)
                              -> libc::c_uint>,
    pub deserialize: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                 _: *const libc::c_char,
                                                 _: libc::c_uint) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSLexer {
    pub lookahead: int32_t,
    pub result_symbol: TSSymbol,
    pub advance: Option<unsafe extern "C" fn(_: *mut TSLexer, _: bool) -> ()>,
    pub mark_end: Option<unsafe extern "C" fn(_: *mut TSLexer) -> ()>,
    pub get_column: Option<unsafe extern "C" fn(_: *mut TSLexer) -> uint32_t>,
    pub is_at_included_range_start: Option<unsafe extern "C" fn(_:
                                                                    *const TSLexer)
                                               -> bool>,
    pub eof: Option<unsafe extern "C" fn(_: *const TSLexer) -> bool>,
}
pub type TSStateId = uint16_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSLexMode {
    pub lex_state: uint16_t,
    pub external_lex_state: uint16_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union TSParseActionEntry {
    pub action: TSParseAction,
    pub entry: C2RustUnnamed_0,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct C2RustUnnamed_0 {
    pub count: uint8_t,
    #[bitfield(name = "reusable", ty = "bool", bits = "0..=0")]
    pub reusable: [u8; 1],
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct TSParseAction {
    pub params: C2RustUnnamed_1,
    #[bitfield(name = "type_0", ty = "TSParseActionType", bits = "0..=3")]
    pub type_0: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 1],
}
pub type TSParseActionType = libc::c_uint;
pub const TSParseActionTypeRecover: TSParseActionType = 3;
pub const TSParseActionTypeAccept: TSParseActionType = 2;
pub const TSParseActionTypeReduce: TSParseActionType = 1;
pub const TSParseActionTypeShift: TSParseActionType = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_1 {
    pub shift: C2RustUnnamed_3,
    pub reduce: C2RustUnnamed_2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub symbol: TSSymbol,
    pub dynamic_precedence: int16_t,
    pub child_count: uint8_t,
    pub production_id: uint8_t,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct C2RustUnnamed_3 {
    pub state: TSStateId,
    #[bitfield(name = "extra", ty = "bool", bits = "0..=0")]
    #[bitfield(name = "repetition", ty = "bool", bits = "1..=1")]
    pub extra_repetition: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 1],
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct TSSymbolMetadata {
    #[bitfield(name = "visible", ty = "bool", bits = "0..=0")]
    #[bitfield(name = "named", ty = "bool", bits = "1..=1")]
    pub visible_named: [u8; 1],
}
/*
 * TSQuery - A tree query, compiled from a string of S-expressions. The query
 * itself is immutable. The mutable state used in the process of executing the
 * query is stored in a `TSQueryCursor`.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSQuery {
    pub captures: SymbolTable,
    pub predicate_values: SymbolTable,
    pub steps: C2RustUnnamed_8,
    pub pattern_map: C2RustUnnamed_7,
    pub predicate_steps: C2RustUnnamed_6,
    pub predicates_by_pattern: C2RustUnnamed_5,
    pub start_bytes_by_pattern: C2RustUnnamed_4,
    pub language: *const TSLanguage,
    pub wildcard_root_pattern_count: uint16_t,
    pub symbol_map: *mut TSSymbol,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_4 {
    pub contents: *mut uint32_t,
    pub size: uint32_t,
    pub capacity: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_5 {
    pub contents: *mut Slice,
    pub size: uint32_t,
    pub capacity: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Slice {
    pub offset: uint32_t,
    pub length: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_6 {
    pub contents: *mut TSQueryPredicateStep,
    pub size: uint32_t,
    pub capacity: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSQueryPredicateStep {
    pub type_0: TSQueryPredicateStepType,
    pub value_id: uint32_t,
}
pub type TSQueryPredicateStepType = libc::c_uint;
pub const TSQueryPredicateStepTypeString: TSQueryPredicateStepType = 2;
pub const TSQueryPredicateStepTypeCapture: TSQueryPredicateStepType = 1;
pub const TSQueryPredicateStepTypeDone: TSQueryPredicateStepType = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_7 {
    pub contents: *mut PatternEntry,
    pub size: uint32_t,
    pub capacity: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PatternEntry {
    pub step_index: uint16_t,
    pub pattern_index: uint16_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_8 {
    pub contents: *mut QueryStep,
    pub size: uint32_t,
    pub capacity: uint32_t,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct QueryStep {
    pub symbol: TSSymbol,
    pub field: TSFieldId,
    pub capture_ids: [uint16_t; 3],
    pub alternative_index: uint16_t,
    pub depth: uint16_t,
    #[bitfield(name = "contains_captures", ty = "bool", bits = "0..=0")]
    #[bitfield(name = "is_pattern_start", ty = "bool", bits = "1..=1")]
    #[bitfield(name = "is_immediate", ty = "bool", bits = "2..=2")]
    #[bitfield(name = "is_last_child", ty = "bool", bits = "3..=3")]
    #[bitfield(name = "is_pass_through", ty = "bool", bits = "4..=4")]
    #[bitfield(name = "is_dead_end", ty = "bool", bits = "5..=5")]
    #[bitfield(name = "alternative_is_immediate", ty = "bool", bits =
               "6..=6")]
    pub contains_captures_is_pattern_start_is_immediate_is_last_child_is_pass_through_is_dead_end_alternative_is_immediate: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SymbolTable {
    pub characters: C2RustUnnamed_10,
    pub slices: C2RustUnnamed_9,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_9 {
    pub contents: *mut Slice,
    pub size: uint32_t,
    pub capacity: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_10 {
    pub contents: *mut libc::c_char,
    pub size: uint32_t,
    pub capacity: uint32_t,
}
/*
 * TSQueryCursor - A stateful struct used to execute a query on a tree.
 */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSQueryCursor {
    pub query: *const TSQuery,
    pub cursor: TSTreeCursor,
    pub states: C2RustUnnamed_12,
    pub finished_states: C2RustUnnamed_11,
    pub capture_list_pool: CaptureListPool,
    pub depth: uint32_t,
    pub start_byte: uint32_t,
    pub end_byte: uint32_t,
    pub next_state_id: uint32_t,
    pub start_point: TSPoint,
    pub end_point: TSPoint,
    pub ascending: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSPoint {
    pub row: uint32_t,
    pub column: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CaptureListPool {
    pub list: [CaptureList; 32],
    pub empty_list: CaptureList,
    pub usage_map: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CaptureList {
    pub contents: *mut TSQueryCapture,
    pub size: uint32_t,
    pub capacity: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSQueryCapture {
    pub node: TSNode,
    pub index: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSNode {
    pub context: [uint32_t; 4],
    pub id: *const libc::c_void,
    pub tree: *const TSTree,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_11 {
    pub contents: *mut QueryState,
    pub size: uint32_t,
    pub capacity: uint32_t,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct QueryState {
    pub id: uint32_t,
    pub start_depth: uint16_t,
    pub step_index: uint16_t,
    pub pattern_index: uint16_t,
    pub capture_list_id: uint16_t,
    #[bitfield(name = "consumed_capture_count", ty = "uint16_t", bits =
               "0..=13")]
    #[bitfield(name = "seeking_immediate_match", ty = "bool", bits =
               "14..=14")]
    #[bitfield(name = "has_in_progress_alternatives", ty = "bool", bits =
               "15..=15")]
    pub consumed_capture_count_seeking_immediate_match_has_in_progress_alternatives: [u8; 2],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_12 {
    pub contents: *mut QueryState,
    pub size: uint32_t,
    pub capacity: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSTreeCursor {
    pub tree: *const libc::c_void,
    pub id: *const libc::c_void,
    pub context: [uint32_t; 2],
}
pub type TSSymbolType = libc::c_uint;
pub const TSSymbolTypeAuxiliary: TSSymbolType = 2;
pub const TSSymbolTypeAnonymous: TSSymbolType = 1;
pub const TSSymbolTypeRegular: TSSymbolType = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSQueryMatch {
    pub id: uint32_t,
    pub pattern_index: uint16_t,
    pub capture_count: uint16_t,
    pub captures: *const TSQueryCapture,
}
pub type TSQueryError = libc::c_uint;
pub const TSQueryErrorCapture: TSQueryError = 4;
pub const TSQueryErrorField: TSQueryError = 3;
pub const TSQueryErrorNodeType: TSQueryError = 2;
pub const TSQueryErrorSyntax: TSQueryError = 1;
pub const TSQueryErrorNone: TSQueryError = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct VoidArray {
    pub contents: *mut libc::c_void,
    pub size: uint32_t,
    pub capacity: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Stream {
    pub input: *const libc::c_char,
    pub end: *const libc::c_char,
    pub next: int32_t,
    pub next_size: uint8_t,
}
pub type wint_t = libc::c_uint;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_13 {
    pub contents: *mut uint32_t,
    pub size: uint32_t,
    pub capacity: uint32_t,
}
#[inline]
unsafe extern "C" fn ts_malloc(mut size: size_t) -> *mut libc::c_void {
    let mut result: *mut libc::c_void = malloc(size);
    if size > 0 as libc::c_int as libc::c_ulong && result.is_null() {
        fprintf(stderr,
                b"tree-sitter failed to allocate %lu bytes\x00" as *const u8
                    as *const libc::c_char, size);
        exit(1 as libc::c_int);
    }
    return result;
}
#[inline]
unsafe extern "C" fn ts_calloc(mut count: size_t, mut size: size_t)
 -> *mut libc::c_void {
    let mut result: *mut libc::c_void = calloc(count, size);
    if count > 0 as libc::c_int as libc::c_ulong && result.is_null() {
        fprintf(stderr,
                b"tree-sitter failed to allocate %lu bytes\x00" as *const u8
                    as *const libc::c_char, count.wrapping_mul(size));
        exit(1 as libc::c_int);
    }
    return result;
}
#[inline]
unsafe extern "C" fn ts_realloc(mut buffer: *mut libc::c_void,
                                mut size: size_t) -> *mut libc::c_void {
    let mut result: *mut libc::c_void = realloc(buffer, size);
    if size > 0 as libc::c_int as libc::c_ulong && result.is_null() {
        fprintf(stderr,
                b"tree-sitter failed to reallocate %lu bytes\x00" as *const u8
                    as *const libc::c_char, size);
        exit(1 as libc::c_int);
    }
    return result;
}
#[inline]
unsafe extern "C" fn ts_free(mut buffer: *mut libc::c_void) { free(buffer); }
// Private
#[inline]
unsafe extern "C" fn array__grow(mut self_0: *mut VoidArray,
                                 mut count: size_t,
                                 mut element_size: size_t) {
    let mut new_size: size_t =
        ((*self_0).size as libc::c_ulong).wrapping_add(count);
    if new_size > (*self_0).capacity as libc::c_ulong {
        let mut new_capacity: size_t =
            (*self_0).capacity.wrapping_mul(2 as libc::c_int as libc::c_uint)
                as size_t;
        if new_capacity < 8 as libc::c_int as libc::c_ulong {
            new_capacity = 8 as libc::c_int as size_t
        }
        if new_capacity < new_size { new_capacity = new_size }
        array__reserve(self_0, element_size, new_capacity as uint32_t);
    };
}
#[inline]
unsafe extern "C" fn array__erase(mut self_0: *mut VoidArray,
                                  mut element_size: size_t,
                                  mut index: uint32_t) {
    if index < (*self_0).size {
    } else {
        __assert_fail(b"index < self->size\x00" as *const u8 as
                          *const libc::c_char,
                      b"lib/src/./array.h\x00" as *const u8 as
                          *const libc::c_char,
                      84 as libc::c_int as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 49],
                                                &[libc::c_char; 49]>(b"void array__erase(VoidArray *, size_t, uint32_t)\x00")).as_ptr());
    }
    let mut contents: *mut libc::c_char =
        (*self_0).contents as *mut libc::c_char;
    memmove(contents.offset((index as
                                 libc::c_ulong).wrapping_mul(element_size) as
                                isize) as *mut libc::c_void,
            contents.offset((index.wrapping_add(1 as libc::c_int as
                                                    libc::c_uint) as
                                 libc::c_ulong).wrapping_mul(element_size) as
                                isize) as *const libc::c_void,
            ((*self_0).size.wrapping_sub(index).wrapping_sub(1 as libc::c_int
                                                                 as
                                                                 libc::c_uint)
                 as libc::c_ulong).wrapping_mul(element_size));
    (*self_0).size = (*self_0).size.wrapping_sub(1);
}
#[inline]
unsafe extern "C" fn array__delete(mut self_0: *mut VoidArray) {
    ts_free((*self_0).contents);
    (*self_0).contents = 0 as *mut libc::c_void;
    (*self_0).size = 0 as libc::c_int as uint32_t;
    (*self_0).capacity = 0 as libc::c_int as uint32_t;
}
#[inline]
unsafe extern "C" fn array__reserve(mut self_0: *mut VoidArray,
                                    mut element_size: size_t,
                                    mut new_capacity: uint32_t) {
    if new_capacity > (*self_0).capacity {
        if !(*self_0).contents.is_null() {
            (*self_0).contents =
                ts_realloc((*self_0).contents,
                           (new_capacity as
                                libc::c_ulong).wrapping_mul(element_size))
        } else {
            (*self_0).contents =
                ts_calloc(new_capacity as size_t, element_size)
        }
        (*self_0).capacity = new_capacity
    };
}
#[inline]
unsafe extern "C" fn array__splice(mut self_0: *mut VoidArray,
                                   mut element_size: size_t,
                                   mut index: uint32_t,
                                   mut old_count: uint32_t,
                                   mut new_count: uint32_t,
                                   mut elements: *const libc::c_void) {
    let mut new_size: uint32_t =
        (*self_0).size.wrapping_add(new_count).wrapping_sub(old_count);
    let mut old_end: uint32_t = index.wrapping_add(old_count);
    let mut new_end: uint32_t = index.wrapping_add(new_count);
    if old_end <= (*self_0).size {
    } else {
        __assert_fail(b"old_end <= self->size\x00" as *const u8 as
                          *const libc::c_char,
                      b"lib/src/./array.h\x00" as *const u8 as
                          *const libc::c_char,
                      124 as libc::c_int as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 84],
                                                &[libc::c_char; 84]>(b"void array__splice(VoidArray *, size_t, uint32_t, uint32_t, uint32_t, const void *)\x00")).as_ptr());
    }
    array__reserve(self_0, element_size, new_size);
    let mut contents: *mut libc::c_char =
        (*self_0).contents as *mut libc::c_char;
    if (*self_0).size > old_end {
        memmove(contents.offset((new_end as
                                     libc::c_ulong).wrapping_mul(element_size)
                                    as isize) as *mut libc::c_void,
                contents.offset((old_end as
                                     libc::c_ulong).wrapping_mul(element_size)
                                    as isize) as *const libc::c_void,
                ((*self_0).size.wrapping_sub(old_end) as
                     libc::c_ulong).wrapping_mul(element_size));
    }
    if new_count > 0 as libc::c_int as libc::c_uint {
        if !elements.is_null() {
            memcpy(contents.offset((index as
                                        libc::c_ulong).wrapping_mul(element_size)
                                       as isize) as *mut libc::c_void,
                   elements,
                   (new_count as libc::c_ulong).wrapping_mul(element_size));
        } else {
            memset(contents.offset((index as
                                        libc::c_ulong).wrapping_mul(element_size)
                                       as isize) as *mut libc::c_void,
                   0 as libc::c_int,
                   (new_count as libc::c_ulong).wrapping_mul(element_size));
        }
    }
    (*self_0).size =
        ((*self_0).size as
             libc::c_uint).wrapping_add(new_count.wrapping_sub(old_count)) as
            uint32_t as uint32_t;
}
#[inline]
unsafe extern "C" fn bitmask_for_index(mut id: uint16_t) -> uint32_t {
    return (1 as libc::c_uint) << 31 as libc::c_int - id as libc::c_int;
}
#[inline]
unsafe extern "C" fn count_leading_zeros(mut x: uint32_t) -> uint32_t {
    if x == 0 as libc::c_int as libc::c_uint {
        return 32 as libc::c_int as uint32_t
    }
    return x.leading_zeros() as i32 as uint32_t;
}
#[inline]
unsafe extern "C" fn point_lte(mut a: TSPoint, mut b: TSPoint) -> bool {
    return a.row < b.row || a.row == b.row && a.column <= b.column;
}
#[inline]
unsafe extern "C" fn ts_decode_utf8(mut string: *const uint8_t,
                                    mut length: uint32_t,
                                    mut code_point: *mut int32_t)
 -> uint32_t {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    let fresh0 = i;
    i = i.wrapping_add(1);
    *code_point = *string.offset(fresh0 as isize) as int32_t;
    if !(*code_point & 0x80 as libc::c_int == 0 as libc::c_int) {
        let mut __t: uint8_t = 0 as libc::c_int as uint8_t;
        if !(i != length &&
                 (if *code_point >= 0xe0 as libc::c_int {
                      ((if *code_point < 0xf0 as libc::c_int {
                            *code_point &= 0xf as libc::c_int;
                            __t = *string.offset(i as isize);
                            ((*::std::mem::transmute::<&[u8; 17],
                                                       &[libc::c_char; 17]>(b" 000000000000\x1000\x00"))[*code_point
                                                                                                             as
                                                                                                             usize]
                                 as libc::c_int &
                                 (1 as libc::c_int) <<
                                     (__t as libc::c_int >> 5 as libc::c_int)
                                 != 0 &&
                                 {
                                     __t =
                                         (__t as libc::c_int &
                                              0x3f as libc::c_int) as uint8_t;
                                     (1 as libc::c_int) != 0
                                 }) as libc::c_int
                        } else {
                            *code_point -= 0xf0 as libc::c_int;
                            (*code_point <= 4 as libc::c_int &&
                                 {
                                     __t = *string.offset(i as isize);
                                     ((*::std::mem::transmute::<&[u8; 17],
                                                                &[libc::c_char; 17]>(b"\x00\x00\x00\x00\x00\x00\x00\x00\x1e\x0f\x0f\x0f\x00\x00\x00\x00\x00"))[(__t
                                                                                                                                                                    as
                                                                                                                                                                    libc::c_int
                                                                                                                                                                    >>
                                                                                                                                                                    4
                                                                                                                                                                        as
                                                                                                                                                                        libc::c_int)
                                                                                                                                                                   as
                                                                                                                                                                   usize]
                                          as libc::c_int &
                                          (1 as libc::c_int) << *code_point)
                                         != 0
                                 } &&
                                 {
                                     *code_point =
                                         *code_point << 6 as libc::c_int |
                                             __t as libc::c_int &
                                                 0x3f as libc::c_int;
                                     i = i.wrapping_add(1);
                                     (i) != length
                                 } &&
                                 {
                                     __t =
                                         (*string.offset(i as isize) as
                                              libc::c_int -
                                              0x80 as libc::c_int) as uint8_t;
                                     (__t as libc::c_int) <=
                                         0x3f as libc::c_int
                                 }) as libc::c_int
                        }) != 0 &&
                           {
                               *code_point =
                                   *code_point << 6 as libc::c_int |
                                       __t as libc::c_int;
                               i = i.wrapping_add(1);
                               (i) != length
                           }) as libc::c_int
                  } else {
                      (*code_point >= 0xc2 as libc::c_int &&
                           {
                               *code_point &= 0x1f as libc::c_int;
                               (1 as libc::c_int) != 0
                           }) as libc::c_int
                  }) != 0 &&
                 {
                     __t =
                         (*string.offset(i as isize) as libc::c_int -
                              0x80 as libc::c_int) as uint8_t;
                     (__t as libc::c_int) <= 0x3f as libc::c_int
                 } &&
                 {
                     *code_point =
                         *code_point << 6 as libc::c_int | __t as libc::c_int;
                     i = i.wrapping_add(1);
                     (1 as libc::c_int) != 0
                 }) {
            *code_point = -(1 as libc::c_int)
        }
    }
    return i;
}
static mut PARENT_DONE: TSQueryError = 4294967295 as TSQueryError;
static mut PATTERN_DONE_MARKER: uint16_t = 65535 as libc::c_int as uint16_t;
static mut NONE: uint16_t = 65535 as libc::c_int as uint16_t;
static mut WILDCARD_SYMBOL: TSSymbol = 0 as libc::c_int as TSSymbol;
static mut NAMED_WILDCARD_SYMBOL: TSSymbol =
    (65535 as libc::c_int - 1 as libc::c_int) as TSSymbol;
/* *********
 * Stream
 **********/
// Advance to the next unicode code point in the stream.
unsafe extern "C" fn stream_advance(mut self_0: *mut Stream) -> bool {
    (*self_0).input =
        (*self_0).input.offset((*self_0).next_size as libc::c_int as isize);
    if (*self_0).input < (*self_0).end {
        let mut size: uint32_t =
            ts_decode_utf8((*self_0).input as *const uint8_t,
                           (*self_0).end.wrapping_offset_from((*self_0).input)
                               as libc::c_long as uint32_t,
                           &mut (*self_0).next);
        if size > 0 as libc::c_int as libc::c_uint {
            (*self_0).next_size = size as uint8_t;
            return 1 as libc::c_int != 0
        }
    } else {
        (*self_0).next_size = 0 as libc::c_int as uint8_t;
        (*self_0).next = '\u{0}' as i32
    }
    return 0 as libc::c_int != 0;
}
// Reset the stream to the given input position, represented as a pointer
// into the input string.
unsafe extern "C" fn stream_reset(mut self_0: *mut Stream,
                                  mut input: *const libc::c_char) {
    (*self_0).input = input;
    (*self_0).next_size = 0 as libc::c_int as uint8_t;
    stream_advance(self_0);
}
unsafe extern "C" fn stream_new(mut string: *const libc::c_char,
                                mut length: uint32_t) -> Stream {
    let mut self_0: Stream =
        {
            let mut init =
                Stream{input: string,
                       end: string.offset(length as isize),
                       next: 0 as libc::c_int,
                       next_size: 0,};
            init
        };
    stream_advance(&mut self_0);
    return self_0;
}
unsafe extern "C" fn stream_skip_whitespace(mut stream: *mut Stream) {
    loop  {
        if iswspace((*stream).next as wint_t) != 0 {
            stream_advance(stream);
        } else {
            if !((*stream).next == ';' as i32) { break ; }
            // skip over comments
            stream_advance(stream);
            while (*stream).next != 0 && (*stream).next != '\n' as i32 {
                if !stream_advance(stream) { break ; }
            }
        }
    };
}
unsafe extern "C" fn stream_is_ident_start(mut stream: *mut Stream) -> bool {
    return iswalnum((*stream).next as wint_t) != 0 ||
               (*stream).next == '_' as i32 || (*stream).next == '-' as i32;
}
unsafe extern "C" fn stream_scan_identifier(mut stream: *mut Stream) {
    loop  {
        stream_advance(stream);
        if !(iswalnum((*stream).next as wint_t) != 0 ||
                 (*stream).next == '_' as i32 || (*stream).next == '-' as i32
                 || (*stream).next == '.' as i32 ||
                 (*stream).next == '?' as i32 || (*stream).next == '!' as i32)
           {
            break ;
        }
    };
}
/* *****************
 * CaptureListPool
 ******************/
unsafe extern "C" fn capture_list_pool_new() -> CaptureListPool {
    return {
               let mut init =
                   CaptureListPool{list:
                                       [CaptureList{contents:
                                                        0 as
                                                            *mut TSQueryCapture,
                                                    size: 0,
                                                    capacity: 0,}; 32],
                                   empty_list:
                                       {
                                           let mut init =
                                               CaptureList{contents:
                                                               0 as
                                                                   *mut TSQueryCapture,
                                                           size:
                                                               0 as
                                                                   libc::c_int
                                                                   as
                                                                   uint32_t,
                                                           capacity:
                                                               0 as
                                                                   libc::c_int
                                                                   as
                                                                   uint32_t,};
                                           init
                                       },
                                   usage_map: 4294967295 as libc::c_uint,};
               init
           };
}
unsafe extern "C" fn capture_list_pool_reset(mut self_0:
                                                 *mut CaptureListPool) {
    (*self_0).usage_map = 4294967295 as libc::c_uint;
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    while i < 32 as libc::c_int as libc::c_uint {
        (*self_0).list[i as usize].size = 0 as libc::c_int as uint32_t;
        i = i.wrapping_add(1)
    };
}
unsafe extern "C" fn capture_list_pool_delete(mut self_0:
                                                  *mut CaptureListPool) {
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    while i < 32 as libc::c_int as libc::c_uint {
        array__delete(&mut *(*self_0).list.as_mut_ptr().offset(i as isize) as
                          *mut CaptureList as *mut VoidArray);
        i = i.wrapping_add(1)
    };
}
unsafe extern "C" fn capture_list_pool_get(mut self_0: *const CaptureListPool,
                                           mut id: uint16_t)
 -> *const CaptureList {
    if id as libc::c_int >= 32 as libc::c_int { return &(*self_0).empty_list }
    return &*(*self_0).list.as_ptr().offset(id as isize) as
               *const CaptureList;
}
unsafe extern "C" fn capture_list_pool_get_mut(mut self_0:
                                                   *mut CaptureListPool,
                                               mut id: uint16_t)
 -> *mut CaptureList {
    if (id as libc::c_int) < 32 as libc::c_int {
    } else {
        __assert_fail(b"id < MAX_CAPTURE_LIST_COUNT\x00" as *const u8 as
                          *const libc::c_char,
                      b"lib/src/query.c\x00" as *const u8 as
                          *const libc::c_char,
                      288 as libc::c_int as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 68],
                                                &[libc::c_char; 68]>(b"CaptureList *capture_list_pool_get_mut(CaptureListPool *, uint16_t)\x00")).as_ptr());
    }
    return &mut *(*self_0).list.as_mut_ptr().offset(id as isize) as
               *mut CaptureList;
}
unsafe extern "C" fn capture_list_pool_is_empty(mut self_0:
                                                    *const CaptureListPool)
 -> bool {
    return (*self_0).usage_map == 0 as libc::c_int as libc::c_uint;
}
unsafe extern "C" fn capture_list_pool_acquire(mut self_0:
                                                   *mut CaptureListPool)
 -> uint16_t {
    // In the usage_map bitmask, ones represent free lists, and zeros represent
  // lists that are in use. A free list id can quickly be found by counting
  // the leading zeros in the usage map. An id of zero corresponds to the
  // highest-order bit in the bitmask.
    let mut id: uint16_t =
        count_leading_zeros((*self_0).usage_map) as uint16_t;
    if id as libc::c_int >= 32 as libc::c_int { return NONE }
    (*self_0).usage_map &= !bitmask_for_index(id);
    (*self_0).list[id as usize].size = 0 as libc::c_int as uint32_t;
    return id;
}
unsafe extern "C" fn capture_list_pool_release(mut self_0:
                                                   *mut CaptureListPool,
                                               mut id: uint16_t) {
    if id as libc::c_int >= 32 as libc::c_int { return }
    (*self_0).list[id as usize].size = 0 as libc::c_int as uint32_t;
    (*self_0).usage_map |= bitmask_for_index(id);
}
/* *************
 * SymbolTable
 **************/
unsafe extern "C" fn symbol_table_new() -> SymbolTable {
    return {
               let mut init =
                   SymbolTable{characters:
                                   {
                                       let mut init =
                                           C2RustUnnamed_10{contents:
                                                                0 as
                                                                    *mut libc::c_char,
                                                            size:
                                                                0 as
                                                                    libc::c_int
                                                                    as
                                                                    uint32_t,
                                                            capacity:
                                                                0 as
                                                                    libc::c_int
                                                                    as
                                                                    uint32_t,};
                                       init
                                   },
                               slices:
                                   {
                                       let mut init =
                                           C2RustUnnamed_9{contents:
                                                               0 as
                                                                   *mut Slice,
                                                           size:
                                                               0 as
                                                                   libc::c_int
                                                                   as
                                                                   uint32_t,
                                                           capacity:
                                                               0 as
                                                                   libc::c_int
                                                                   as
                                                                   uint32_t,};
                                       init
                                   },};
               init
           };
}
unsafe extern "C" fn symbol_table_delete(mut self_0: *mut SymbolTable) {
    array__delete(&mut (*self_0).characters as *mut C2RustUnnamed_10 as
                      *mut VoidArray);
    array__delete(&mut (*self_0).slices as *mut C2RustUnnamed_9 as
                      *mut VoidArray);
}
unsafe extern "C" fn symbol_table_id_for_name(mut self_0: *const SymbolTable,
                                              mut name: *const libc::c_char,
                                              mut length: uint32_t)
 -> libc::c_int {
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    while i < (*self_0).slices.size {
        let mut slice: Slice = *(*self_0).slices.contents.offset(i as isize);
        if slice.length == length &&
               strncmp(&mut *(*self_0).characters.contents.offset(slice.offset
                                                                      as
                                                                      isize),
                       name, length as libc::c_ulong) == 0 {
            return i as libc::c_int
        }
        i = i.wrapping_add(1)
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn symbol_table_name_for_id(mut self_0: *const SymbolTable,
                                              mut id: uint16_t,
                                              mut length: *mut uint32_t)
 -> *const libc::c_char {
    let mut slice: Slice = *(*self_0).slices.contents.offset(id as isize);
    *length = slice.length;
    return &mut *(*self_0).characters.contents.offset(slice.offset as isize)
               as *mut libc::c_char;
}
unsafe extern "C" fn symbol_table_insert_name(mut self_0: *mut SymbolTable,
                                              mut name: *const libc::c_char,
                                              mut length: uint32_t)
 -> uint16_t {
    let mut id: libc::c_int = symbol_table_id_for_name(self_0, name, length);
    if id >= 0 as libc::c_int { return id as uint16_t }
    let mut slice: Slice =
        {
            let mut init =
                Slice{offset: (*self_0).characters.size, length: length,};
            init
        };
    array__grow(&mut (*self_0).characters as *mut C2RustUnnamed_10 as
                    *mut VoidArray,
                length.wrapping_add(1 as libc::c_int as libc::c_uint) as
                    size_t,
                ::std::mem::size_of::<libc::c_char>() as libc::c_ulong);
    memset((*self_0).characters.contents.offset((*self_0).characters.size as
                                                    isize) as
               *mut libc::c_void, 0 as libc::c_int,
           (length.wrapping_add(1 as libc::c_int as libc::c_uint) as
                libc::c_ulong).wrapping_mul(::std::mem::size_of::<libc::c_char>()
                                                as libc::c_ulong));
    (*self_0).characters.size =
        ((*self_0).characters.size as
             libc::c_uint).wrapping_add(length.wrapping_add(1 as libc::c_int
                                                                as
                                                                libc::c_uint))
            as uint32_t as uint32_t;
    memcpy(&mut *(*self_0).characters.contents.offset(slice.offset as isize)
               as *mut libc::c_char as *mut libc::c_void,
           name as *const libc::c_void, length as libc::c_ulong);
    *(*self_0).characters.contents.offset((*self_0).characters.size.wrapping_sub(1
                                                                                     as
                                                                                     libc::c_int
                                                                                     as
                                                                                     libc::c_uint)
                                              as isize) =
        0 as libc::c_int as libc::c_char;
    array__grow(&mut (*self_0).slices as *mut C2RustUnnamed_9 as
                    *mut VoidArray, 1 as libc::c_int as size_t,
                ::std::mem::size_of::<Slice>() as libc::c_ulong);
    let fresh1 = (*self_0).slices.size;
    (*self_0).slices.size = (*self_0).slices.size.wrapping_add(1);
    *(*self_0).slices.contents.offset(fresh1 as isize) = slice;
    return (*self_0).slices.size.wrapping_sub(1 as libc::c_int as
                                                  libc::c_uint) as uint16_t;
}
unsafe extern "C" fn symbol_table_insert_name_with_escapes(mut self_0:
                                                               *mut SymbolTable,
                                                           mut escaped_name:
                                                               *const libc::c_char,
                                                           mut escaped_length:
                                                               uint32_t)
 -> uint16_t {
    let mut slice: Slice =
        {
            let mut init =
                Slice{offset: (*self_0).characters.size,
                      length: 0 as libc::c_int as uint32_t,};
            init
        };
    array__grow(&mut (*self_0).characters as *mut C2RustUnnamed_10 as
                    *mut VoidArray,
                escaped_length.wrapping_add(1 as libc::c_int as libc::c_uint)
                    as size_t,
                ::std::mem::size_of::<libc::c_char>() as libc::c_ulong);
    memset((*self_0).characters.contents.offset((*self_0).characters.size as
                                                    isize) as
               *mut libc::c_void, 0 as libc::c_int,
           (escaped_length.wrapping_add(1 as libc::c_int as libc::c_uint) as
                libc::c_ulong).wrapping_mul(::std::mem::size_of::<libc::c_char>()
                                                as libc::c_ulong));
    (*self_0).characters.size =
        ((*self_0).characters.size as
             libc::c_uint).wrapping_add(escaped_length.wrapping_add(1 as
                                                                        libc::c_int
                                                                        as
                                                                        libc::c_uint))
            as uint32_t as uint32_t;
    // Copy the contents of the literal into the characters buffer, processing escape
  // sequences like \n and \". This needs to be done before checking if the literal
  // is already present, in order to do the string comparison.
    let mut is_escaped: bool = 0 as libc::c_int != 0;
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    while i < escaped_length {
        let mut src: *const libc::c_char =
            &*escaped_name.offset(i as isize) as *const libc::c_char;
        let mut dest: *mut libc::c_char =
            &mut *(*self_0).characters.contents.offset(slice.offset.wrapping_add(slice.length)
                                                           as isize) as
                *mut libc::c_char;
        if is_escaped {
            match *src as libc::c_int {
                110 => { *dest = '\n' as i32 as libc::c_char }
                114 => { *dest = '\r' as i32 as libc::c_char }
                116 => { *dest = '\t' as i32 as libc::c_char }
                48 => { *dest = '\u{0}' as i32 as libc::c_char }
                _ => { *dest = *src }
            }
            is_escaped = 0 as libc::c_int != 0;
            slice.length = slice.length.wrapping_add(1)
        } else if *src as libc::c_int == '\\' as i32 {
            is_escaped = 1 as libc::c_int != 0
        } else { *dest = *src; slice.length = slice.length.wrapping_add(1) }
        i = i.wrapping_add(1)
    }
    // If the string is already present, remove the redundant content from the characters
  // buffer and return the existing id.
    let mut id: libc::c_int =
        symbol_table_id_for_name(self_0,
                                 &mut *(*self_0).characters.contents.offset(slice.offset
                                                                                as
                                                                                isize),
                                 slice.length);
    if id >= 0 as libc::c_int {
        (*self_0).characters.size =
            ((*self_0).characters.size as
                 libc::c_uint).wrapping_sub(escaped_length.wrapping_add(1 as
                                                                            libc::c_int
                                                                            as
                                                                            libc::c_uint))
                as uint32_t as uint32_t;
        return id as uint16_t
    }
    *(*self_0).characters.contents.offset(slice.offset.wrapping_add(slice.length)
                                              as isize) =
        0 as libc::c_int as libc::c_char;
    array__grow(&mut (*self_0).slices as *mut C2RustUnnamed_9 as
                    *mut VoidArray, 1 as libc::c_int as size_t,
                ::std::mem::size_of::<Slice>() as libc::c_ulong);
    let fresh2 = (*self_0).slices.size;
    (*self_0).slices.size = (*self_0).slices.size.wrapping_add(1);
    *(*self_0).slices.contents.offset(fresh2 as isize) = slice;
    return (*self_0).slices.size.wrapping_sub(1 as libc::c_int as
                                                  libc::c_uint) as uint16_t;
}
/* ***********
 * QueryStep
 ************/
unsafe extern "C" fn query_step__new(mut symbol: TSSymbol,
                                     mut depth: uint16_t,
                                     mut is_immediate: bool) -> QueryStep {
    return {
               let mut init =
                   QueryStep{contains_captures_is_pattern_start_is_immediate_is_last_child_is_pass_through_is_dead_end_alternative_is_immediate:
                                 [0; 1],
                             c2rust_padding: [0; 1],
                             symbol: symbol,
                             field: 0 as libc::c_int as TSFieldId,
                             capture_ids: [NONE, NONE, NONE],
                             alternative_index: NONE,
                             depth: depth,};
               init.set_contains_captures(0 as libc::c_int != 0);
               init.set_is_pattern_start(0 as libc::c_int != 0);
               init.set_is_immediate(is_immediate);
               init.set_is_last_child(0 as libc::c_int != 0);
               init.set_is_pass_through(0 as libc::c_int != 0);
               init.set_is_dead_end(0 as libc::c_int != 0);
               init.set_alternative_is_immediate(0 as libc::c_int != 0);
               init
           };
}
unsafe extern "C" fn query_step__add_capture(mut self_0: *mut QueryStep,
                                             mut capture_id: uint16_t) {
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    while i < 3 as libc::c_int as libc::c_uint {
        if (*self_0).capture_ids[i as usize] as libc::c_int ==
               NONE as libc::c_int {
            (*self_0).capture_ids[i as usize] = capture_id;
            break ;
        } else { i = i.wrapping_add(1) }
    };
}
unsafe extern "C" fn query_step__remove_capture(mut self_0: *mut QueryStep,
                                                mut capture_id: uint16_t) {
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    while i < 3 as libc::c_int as libc::c_uint {
        if (*self_0).capture_ids[i as usize] as libc::c_int ==
               capture_id as libc::c_int {
            (*self_0).capture_ids[i as usize] = NONE;
            while i.wrapping_add(1 as libc::c_int as libc::c_uint) <
                      3 as libc::c_int as libc::c_uint {
                if (*self_0).capture_ids[i.wrapping_add(1 as libc::c_int as
                                                            libc::c_uint) as
                                             usize] as libc::c_int ==
                       NONE as libc::c_int {
                    break ;
                }
                (*self_0).capture_ids[i as usize] =
                    (*self_0).capture_ids[i.wrapping_add(1 as libc::c_int as
                                                             libc::c_uint) as
                                              usize];
                (*self_0).capture_ids[i.wrapping_add(1 as libc::c_int as
                                                         libc::c_uint) as
                                          usize] = NONE;
                i = i.wrapping_add(1)
            }
            break ;
        } else { i = i.wrapping_add(1) }
    };
}
/* ********
 * Query
 *********/
// The `pattern_map` contains a mapping from TSSymbol values to indices in the
// `steps` array. For a given syntax node, the `pattern_map` makes it possible
// to quickly find the starting steps of all of the patterns whose root matches
// that node. Each entry has two fields: a `pattern_index`, which identifies one
// of the patterns in the query, and a `step_index`, which indicates the start
// offset of that pattern's steps within the `steps` array.
//
// The entries are sorted by the patterns' root symbols, and lookups use a
// binary search. This ensures that the cost of this initial lookup step
// scales logarithmically with the number of patterns in the query.
//
// This returns `true` if the symbol is present and `false` otherwise.
// If the symbol is not present `*result` is set to the index where the
// symbol should be inserted.
#[inline]
unsafe extern "C" fn ts_query__pattern_map_search(mut self_0: *const TSQuery,
                                                  mut needle: TSSymbol,
                                                  mut result: *mut uint32_t)
 -> bool {
    let mut base_index: uint32_t =
        (*self_0).wildcard_root_pattern_count as uint32_t;
    let mut size: uint32_t =
        (*self_0).pattern_map.size.wrapping_sub(base_index);
    if size == 0 as libc::c_int as libc::c_uint {
        *result = base_index;
        return 0 as libc::c_int != 0
    }
    while size > 1 as libc::c_int as libc::c_uint {
        let mut half_size: uint32_t =
            size.wrapping_div(2 as libc::c_int as libc::c_uint);
        let mut mid_index: uint32_t = base_index.wrapping_add(half_size);
        let mut mid_symbol: TSSymbol =
            (*(*self_0).steps.contents.offset((*(*self_0).pattern_map.contents.offset(mid_index
                                                                                          as
                                                                                          isize)).step_index
                                                  as isize)).symbol;
        if needle as libc::c_int > mid_symbol as libc::c_int {
            base_index = mid_index
        }
        size =
            (size as libc::c_uint).wrapping_sub(half_size) as uint32_t as
                uint32_t
    }
    let mut symbol: TSSymbol =
        (*(*self_0).steps.contents.offset((*(*self_0).pattern_map.contents.offset(base_index
                                                                                      as
                                                                                      isize)).step_index
                                              as isize)).symbol;
    if needle as libc::c_int > symbol as libc::c_int {
        base_index = base_index.wrapping_add(1);
        if base_index < (*self_0).pattern_map.size {
            symbol =
                (*(*self_0).steps.contents.offset((*(*self_0).pattern_map.contents.offset(base_index
                                                                                              as
                                                                                              isize)).step_index
                                                      as isize)).symbol
        }
    }
    *result = base_index;
    return needle as libc::c_int == symbol as libc::c_int;
}
// Insert a new pattern's start index into the pattern map, maintaining
// the pattern map's ordering invariant.
#[inline]
unsafe extern "C" fn ts_query__pattern_map_insert(mut self_0: *mut TSQuery,
                                                  mut symbol: TSSymbol,
                                                  mut start_step_index:
                                                      uint32_t,
                                                  mut pattern_index:
                                                      uint32_t) {
    let mut index: uint32_t = 0;
    ts_query__pattern_map_search(self_0, symbol, &mut index);
    array__splice(&mut (*self_0).pattern_map as *mut C2RustUnnamed_7 as
                      *mut VoidArray,
                  ::std::mem::size_of::<PatternEntry>() as libc::c_ulong,
                  index, 0 as libc::c_int as uint32_t,
                  1 as libc::c_int as uint32_t,
                  &mut {
                           let mut init =
                               PatternEntry{step_index:
                                                start_step_index as uint16_t,
                                            pattern_index:
                                                pattern_index as uint16_t,};
                           init
                       } as *mut PatternEntry as *const libc::c_void);
}
unsafe extern "C" fn ts_query__finalize_steps(mut self_0: *mut TSQuery) {
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    while i < (*self_0).steps.size {
        let mut step: *mut QueryStep =
            &mut *(*self_0).steps.contents.offset(i as isize) as
                *mut QueryStep;
        let mut depth: uint32_t = (*step).depth as uint32_t;
        if (*step).capture_ids[0 as libc::c_int as usize] as libc::c_int !=
               NONE as libc::c_int {
            (*step).set_contains_captures(1 as libc::c_int != 0)
        } else {
            (*step).set_contains_captures(0 as libc::c_int != 0);
            let mut j: libc::c_uint =
                i.wrapping_add(1 as libc::c_int as libc::c_uint);
            while j < (*self_0).steps.size {
                let mut s: *mut QueryStep =
                    &mut *(*self_0).steps.contents.offset(j as isize) as
                        *mut QueryStep;
                if (*s).depth as libc::c_int ==
                       PATTERN_DONE_MARKER as libc::c_int ||
                       (*s).depth as libc::c_uint <= depth {
                    break ;
                }
                if (*s).capture_ids[0 as libc::c_int as usize] as libc::c_int
                       != NONE as libc::c_int {
                    (*step).set_contains_captures(1 as libc::c_int != 0)
                }
                j = j.wrapping_add(1)
            }
        }
        i = i.wrapping_add(1)
    };
}
// Parse a single predicate associated with a pattern, adding it to the
// query's internal `predicate_steps` array. Predicates are arbitrary
// S-expressions associated with a pattern which are meant to be handled at
// a higher level of abstraction, such as the Rust/JavaScript bindings. They
// can contain '@'-prefixed capture names, double-quoted strings, and bare
// symbols, which also represent strings.
unsafe extern "C" fn ts_query__parse_predicate(mut self_0: *mut TSQuery,
                                               mut stream: *mut Stream)
 -> TSQueryError {
    if !stream_is_ident_start(stream) { return TSQueryErrorSyntax }
    let mut predicate_name: *const libc::c_char = (*stream).input;
    stream_scan_identifier(stream);
    let mut length: uint32_t =
        (*stream).input.wrapping_offset_from(predicate_name) as libc::c_long
            as uint32_t;
    let mut id: uint16_t =
        symbol_table_insert_name(&mut (*self_0).predicate_values,
                                 predicate_name, length);
    if (*self_0).predicates_by_pattern.size.wrapping_sub(1 as libc::c_int as
                                                             libc::c_uint) <
           (*self_0).predicates_by_pattern.size {
    } else {
        __assert_fail(b"(uint32_t)(&self->predicates_by_pattern)->size - 1 < (&self->predicates_by_pattern)->size\x00"
                          as *const u8 as *const libc::c_char,
                      b"lib/src/query.c\x00" as *const u8 as
                          *const libc::c_char,
                      591 as libc::c_int as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 60],
                                                &[libc::c_char; 60]>(b"TSQueryError ts_query__parse_predicate(TSQuery *, Stream *)\x00")).as_ptr());
    }
    let ref mut fresh3 =
        (*(&mut *(*self_0).predicates_by_pattern.contents.offset((*self_0).predicates_by_pattern.size.wrapping_sub(1
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       libc::c_uint)
                                                                     as isize)
               as *mut Slice)).length;
    *fresh3 = (*fresh3).wrapping_add(1);
    array__grow(&mut (*self_0).predicate_steps as *mut C2RustUnnamed_6 as
                    *mut VoidArray, 1 as libc::c_int as size_t,
                ::std::mem::size_of::<TSQueryPredicateStep>() as
                    libc::c_ulong);
    let fresh4 = (*self_0).predicate_steps.size;
    (*self_0).predicate_steps.size =
        (*self_0).predicate_steps.size.wrapping_add(1);
    *(*self_0).predicate_steps.contents.offset(fresh4 as isize) =
        {
            let mut init =
                TSQueryPredicateStep{type_0: TSQueryPredicateStepTypeString,
                                     value_id: id as uint32_t,};
            init
        };
    stream_skip_whitespace(stream);
    loop  {
        if (*stream).next == ')' as i32 {
            stream_advance(stream);
            stream_skip_whitespace(stream);
            if (*self_0).predicates_by_pattern.size.wrapping_sub(1 as
                                                                     libc::c_int
                                                                     as
                                                                     libc::c_uint)
                   < (*self_0).predicates_by_pattern.size {
            } else {
                __assert_fail(b"(uint32_t)(&self->predicates_by_pattern)->size - 1 < (&self->predicates_by_pattern)->size\x00"
                                  as *const u8 as *const libc::c_char,
                              b"lib/src/query.c\x00" as *const u8 as
                                  *const libc::c_char,
                              602 as libc::c_int as libc::c_uint,
                              (*::std::mem::transmute::<&[u8; 60],
                                                        &[libc::c_char; 60]>(b"TSQueryError ts_query__parse_predicate(TSQuery *, Stream *)\x00")).as_ptr());
            }
            let ref mut fresh5 =
                (*(&mut *(*self_0).predicates_by_pattern.contents.offset((*self_0).predicates_by_pattern.size.wrapping_sub(1
                                                                                                                               as
                                                                                                                               libc::c_int
                                                                                                                               as
                                                                                                                               libc::c_uint)
                                                                             as
                                                                             isize)
                       as *mut Slice)).length;
            *fresh5 = (*fresh5).wrapping_add(1);
            array__grow(&mut (*self_0).predicate_steps as *mut C2RustUnnamed_6
                            as *mut VoidArray, 1 as libc::c_int as size_t,
                        ::std::mem::size_of::<TSQueryPredicateStep>() as
                            libc::c_ulong);
            let fresh6 = (*self_0).predicate_steps.size;
            (*self_0).predicate_steps.size =
                (*self_0).predicate_steps.size.wrapping_add(1);
            *(*self_0).predicate_steps.contents.offset(fresh6 as isize) =
                {
                    let mut init =
                        TSQueryPredicateStep{type_0:
                                                 TSQueryPredicateStepTypeDone,
                                             value_id:
                                                 0 as libc::c_int as
                                                     uint32_t,};
                    init
                };
            break ;
        } else {
            // Parse an '@'-prefixed capture name
            if (*stream).next == '@' as i32 {
                stream_advance(stream);
                // Parse the capture name
                if !stream_is_ident_start(stream) {
                    return TSQueryErrorSyntax
                }
                let mut capture_name: *const libc::c_char = (*stream).input;
                stream_scan_identifier(stream);
                let mut length_0: uint32_t =
                    (*stream).input.wrapping_offset_from(capture_name) as
                        libc::c_long as uint32_t;
                // Add the capture id to the first step of the pattern
                let mut capture_id: libc::c_int =
                    symbol_table_id_for_name(&mut (*self_0).captures,
                                             capture_name, length_0);
                if capture_id == -(1 as libc::c_int) {
                    stream_reset(stream, capture_name);
                    return TSQueryErrorCapture
                }
                if (*self_0).predicates_by_pattern.size.wrapping_sub(1 as
                                                                         libc::c_int
                                                                         as
                                                                         libc::c_uint)
                       < (*self_0).predicates_by_pattern.size {
                } else {
                    __assert_fail(b"(uint32_t)(&self->predicates_by_pattern)->size - 1 < (&self->predicates_by_pattern)->size\x00"
                                      as *const u8 as *const libc::c_char,
                                  b"lib/src/query.c\x00" as *const u8 as
                                      *const libc::c_char,
                                  631 as libc::c_int as libc::c_uint,
                                  (*::std::mem::transmute::<&[u8; 60],
                                                            &[libc::c_char; 60]>(b"TSQueryError ts_query__parse_predicate(TSQuery *, Stream *)\x00")).as_ptr());
                }
                let ref mut fresh7 =
                    (*(&mut *(*self_0).predicates_by_pattern.contents.offset((*self_0).predicates_by_pattern.size.wrapping_sub(1
                                                                                                                                   as
                                                                                                                                   libc::c_int
                                                                                                                                   as
                                                                                                                                   libc::c_uint)
                                                                                 as
                                                                                 isize)
                           as *mut Slice)).length;
                *fresh7 = (*fresh7).wrapping_add(1);
                array__grow(&mut (*self_0).predicate_steps as
                                *mut C2RustUnnamed_6 as *mut VoidArray,
                            1 as libc::c_int as size_t,
                            ::std::mem::size_of::<TSQueryPredicateStep>() as
                                libc::c_ulong);
                let fresh8 = (*self_0).predicate_steps.size;
                (*self_0).predicate_steps.size =
                    (*self_0).predicate_steps.size.wrapping_add(1);
                *(*self_0).predicate_steps.contents.offset(fresh8 as isize) =
                    {
                        let mut init =
                            TSQueryPredicateStep{type_0:
                                                     TSQueryPredicateStepTypeCapture,
                                                 value_id:
                                                     capture_id as uint32_t,};
                        init
                    }
            } else if (*stream).next == '\"' as i32 {
                stream_advance(stream);
                // Parse a string literal
                // Parse the string content
                let mut is_escaped: bool = 0 as libc::c_int != 0;
                let mut string_content: *const libc::c_char = (*stream).input;
                loop  {
                    if is_escaped {
                        is_escaped = 0 as libc::c_int != 0
                    } else if (*stream).next == '\\' as i32 {
                        is_escaped = 1 as libc::c_int != 0
                    } else {
                        if (*stream).next == '\"' as i32 { break ; }
                        if (*stream).next == '\n' as i32 {
                            stream_reset(stream,
                                         string_content.offset(-(1 as
                                                                     libc::c_int
                                                                     as
                                                                     isize)));
                            return TSQueryErrorSyntax
                        }
                    }
                    if !stream_advance(stream) {
                        stream_reset(stream,
                                     string_content.offset(-(1 as libc::c_int
                                                                 as isize)));
                        return TSQueryErrorSyntax
                    }
                }
                let mut length_1: uint32_t =
                    (*stream).input.wrapping_offset_from(string_content) as
                        libc::c_long as uint32_t;
                // Add a step for the node
                let mut id_0: uint16_t =
                    symbol_table_insert_name_with_escapes(&mut (*self_0).predicate_values,
                                                          string_content,
                                                          length_1);
                if (*self_0).predicates_by_pattern.size.wrapping_sub(1 as
                                                                         libc::c_int
                                                                         as
                                                                         libc::c_uint)
                       < (*self_0).predicates_by_pattern.size {
                } else {
                    __assert_fail(b"(uint32_t)(&self->predicates_by_pattern)->size - 1 < (&self->predicates_by_pattern)->size\x00"
                                      as *const u8 as *const libc::c_char,
                                  b"lib/src/query.c\x00" as *const u8 as
                                      *const libc::c_char,
                                  671 as libc::c_int as libc::c_uint,
                                  (*::std::mem::transmute::<&[u8; 60],
                                                            &[libc::c_char; 60]>(b"TSQueryError ts_query__parse_predicate(TSQuery *, Stream *)\x00")).as_ptr());
                }
                let ref mut fresh9 =
                    (*(&mut *(*self_0).predicates_by_pattern.contents.offset((*self_0).predicates_by_pattern.size.wrapping_sub(1
                                                                                                                                   as
                                                                                                                                   libc::c_int
                                                                                                                                   as
                                                                                                                                   libc::c_uint)
                                                                                 as
                                                                                 isize)
                           as *mut Slice)).length;
                *fresh9 = (*fresh9).wrapping_add(1);
                array__grow(&mut (*self_0).predicate_steps as
                                *mut C2RustUnnamed_6 as *mut VoidArray,
                            1 as libc::c_int as size_t,
                            ::std::mem::size_of::<TSQueryPredicateStep>() as
                                libc::c_ulong);
                let fresh10 = (*self_0).predicate_steps.size;
                (*self_0).predicate_steps.size =
                    (*self_0).predicate_steps.size.wrapping_add(1);
                *(*self_0).predicate_steps.contents.offset(fresh10 as isize) =
                    {
                        let mut init =
                            TSQueryPredicateStep{type_0:
                                                     TSQueryPredicateStepTypeString,
                                                 value_id: id_0 as uint32_t,};
                        init
                    };
                if (*stream).next != '\"' as i32 { return TSQueryErrorSyntax }
                stream_advance(stream);
            } else if stream_is_ident_start(stream) {
                let mut symbol_start: *const libc::c_char = (*stream).input;
                stream_scan_identifier(stream);
                let mut length_2: uint32_t =
                    (*stream).input.wrapping_offset_from(symbol_start) as
                        libc::c_long as uint32_t;
                let mut id_1: uint16_t =
                    symbol_table_insert_name(&mut (*self_0).predicate_values,
                                             symbol_start, length_2);
                if (*self_0).predicates_by_pattern.size.wrapping_sub(1 as
                                                                         libc::c_int
                                                                         as
                                                                         libc::c_uint)
                       < (*self_0).predicates_by_pattern.size {
                } else {
                    __assert_fail(b"(uint32_t)(&self->predicates_by_pattern)->size - 1 < (&self->predicates_by_pattern)->size\x00"
                                      as *const u8 as *const libc::c_char,
                                  b"lib/src/query.c\x00" as *const u8 as
                                      *const libc::c_char,
                                  691 as libc::c_int as libc::c_uint,
                                  (*::std::mem::transmute::<&[u8; 60],
                                                            &[libc::c_char; 60]>(b"TSQueryError ts_query__parse_predicate(TSQuery *, Stream *)\x00")).as_ptr());
                }
                let ref mut fresh11 =
                    (*(&mut *(*self_0).predicates_by_pattern.contents.offset((*self_0).predicates_by_pattern.size.wrapping_sub(1
                                                                                                                                   as
                                                                                                                                   libc::c_int
                                                                                                                                   as
                                                                                                                                   libc::c_uint)
                                                                                 as
                                                                                 isize)
                           as *mut Slice)).length;
                *fresh11 = (*fresh11).wrapping_add(1);
                array__grow(&mut (*self_0).predicate_steps as
                                *mut C2RustUnnamed_6 as *mut VoidArray,
                            1 as libc::c_int as size_t,
                            ::std::mem::size_of::<TSQueryPredicateStep>() as
                                libc::c_ulong);
                let fresh12 = (*self_0).predicate_steps.size;
                (*self_0).predicate_steps.size =
                    (*self_0).predicate_steps.size.wrapping_add(1);
                *(*self_0).predicate_steps.contents.offset(fresh12 as isize) =
                    {
                        let mut init =
                            TSQueryPredicateStep{type_0:
                                                     TSQueryPredicateStepTypeString,
                                                 value_id: id_1 as uint32_t,};
                        init
                    }
            } else { return TSQueryErrorSyntax }
            stream_skip_whitespace(stream);
        }
    }
    return TSQueryErrorNone;
}
// Parse a bare symbol
// Read one S-expression pattern from the stream, and incorporate it into
// the query's internal state machine representation. For nested patterns,
// this function calls itself recursively.
unsafe extern "C" fn ts_query__parse_pattern(mut self_0: *mut TSQuery,
                                             mut stream: *mut Stream,
                                             mut depth: uint32_t,
                                             mut capture_count: *mut uint32_t,
                                             mut is_immediate: bool)
 -> TSQueryError {
    let mut starting_step_index: uint32_t = (*self_0).steps.size;
    if (*stream).next == 0 as libc::c_int { return TSQueryErrorSyntax }
    // Finish the parent S-expression.
    if (*stream).next == ')' as i32 || (*stream).next == ']' as i32 {
        return PARENT_DONE
    } else {
        // An open bracket is the start of an alternation.
        if (*stream).next == '[' as i32 {
            stream_advance(stream);
            stream_skip_whitespace(stream);
            // Parse each branch, and add a placeholder step in between the branches.
            let mut branch_step_indices: C2RustUnnamed_13 =
                {
                    let mut init =
                        C2RustUnnamed_13{contents: 0 as *mut uint32_t,
                                         size: 0 as libc::c_int as uint32_t,
                                         capacity:
                                             0 as libc::c_int as uint32_t,};
                    init
                };
            loop  {
                let mut start_index: uint32_t = (*self_0).steps.size;
                let mut e: TSQueryError =
                    ts_query__parse_pattern(self_0, stream, depth,
                                            capture_count, is_immediate);
                if e as libc::c_uint == PARENT_DONE as libc::c_uint &&
                       (*stream).next == ']' as i32 &&
                       branch_step_indices.size >
                           0 as libc::c_int as libc::c_uint {
                    stream_advance(stream);
                    break ;
                } else {
                    if e as u64 != 0 {
                        array__delete(&mut branch_step_indices as
                                          *mut C2RustUnnamed_13 as
                                          *mut VoidArray);
                        return e
                    }
                    array__grow(&mut branch_step_indices as
                                    *mut C2RustUnnamed_13 as *mut VoidArray,
                                1 as libc::c_int as size_t,
                                ::std::mem::size_of::<uint32_t>() as
                                    libc::c_ulong);
                    let fresh13 = branch_step_indices.size;
                    branch_step_indices.size =
                        branch_step_indices.size.wrapping_add(1);
                    *branch_step_indices.contents.offset(fresh13 as isize) =
                        start_index;
                    array__grow(&mut (*self_0).steps as *mut C2RustUnnamed_8
                                    as *mut VoidArray,
                                1 as libc::c_int as size_t,
                                ::std::mem::size_of::<QueryStep>() as
                                    libc::c_ulong);
                    let fresh14 = (*self_0).steps.size;
                    (*self_0).steps.size =
                        (*self_0).steps.size.wrapping_add(1);
                    *(*self_0).steps.contents.offset(fresh14 as isize) =
                        query_step__new(0 as libc::c_int as TSSymbol,
                                        depth as uint16_t,
                                        0 as libc::c_int != 0)
                }
            }
            (*self_0).steps.size = (*self_0).steps.size.wrapping_sub(1);
            // For all of the branches except for the last one, add the subsequent branch as an
    // alternative, and link the end of the branch to the current end of the steps.
            let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
            while i <
                      branch_step_indices.size.wrapping_sub(1 as libc::c_int
                                                                as
                                                                libc::c_uint)
                  {
                let mut step_index: uint32_t =
                    *branch_step_indices.contents.offset(i as isize);
                let mut next_step_index: uint32_t =
                    *branch_step_indices.contents.offset(i.wrapping_add(1 as
                                                                            libc::c_int
                                                                            as
                                                                            libc::c_uint)
                                                             as isize);
                let mut start_step: *mut QueryStep =
                    &mut *(*self_0).steps.contents.offset(step_index as isize)
                        as *mut QueryStep;
                let mut end_step: *mut QueryStep =
                    &mut *(*self_0).steps.contents.offset(next_step_index.wrapping_sub(1
                                                                                           as
                                                                                           libc::c_int
                                                                                           as
                                                                                           libc::c_uint)
                                                              as isize) as
                        *mut QueryStep;
                (*start_step).alternative_index = next_step_index as uint16_t;
                (*end_step).alternative_index =
                    (*self_0).steps.size as uint16_t;
                (*end_step).set_is_dead_end(1 as libc::c_int != 0);
                i = i.wrapping_add(1)
            }
            array__delete(&mut branch_step_indices as *mut C2RustUnnamed_13 as
                              *mut VoidArray);
        } else if (*stream).next == '(' as i32 {
            stream_advance(stream);
            stream_skip_whitespace(stream);
            // An open parenthesis can be the start of three possible constructs:
  // * A grouped sequence
  // * A predicate
  // * A named node
            // If this parenthesis is followed by a node, then it represents a grouped sequence.
            if (*stream).next == '(' as i32 || (*stream).next == '\"' as i32
                   || (*stream).next == '[' as i32 {
                let mut child_is_immediate: bool = 0 as libc::c_int != 0;
                loop  {
                    if (*stream).next == '.' as i32 {
                        child_is_immediate = 1 as libc::c_int != 0;
                        stream_advance(stream);
                        stream_skip_whitespace(stream);
                    }
                    let mut e_0: TSQueryError =
                        ts_query__parse_pattern(self_0, stream, depth,
                                                capture_count,
                                                child_is_immediate);
                    if e_0 as libc::c_uint == PARENT_DONE as libc::c_uint &&
                           (*stream).next == ')' as i32 {
                        stream_advance(stream);
                        break ;
                    } else {
                        if e_0 as u64 != 0 { return e_0 }
                        child_is_immediate = 0 as libc::c_int != 0
                    }
                }
            } else if (*stream).next == '#' as i32 {
                stream_advance(stream);
                return ts_query__parse_predicate(self_0, stream)
            } else {
                // A pound character indicates the start of a predicate.
                // Otherwise, this parenthesis is the start of a named node.
                let mut symbol: TSSymbol = 0;
                // Parse the wildcard symbol
                if (*stream).next == '_' as i32 ||
                       (*stream).next == '*' as i32 {
                    symbol =
                        if depth > 0 as libc::c_int as libc::c_uint {
                            NAMED_WILDCARD_SYMBOL as libc::c_int
                        } else { WILDCARD_SYMBOL as libc::c_int } as TSSymbol;
                    stream_advance(stream);
                } else if stream_is_ident_start(stream) {
                    let mut node_name: *const libc::c_char = (*stream).input;
                    stream_scan_identifier(stream);
                    let mut length: uint32_t =
                        (*stream).input.wrapping_offset_from(node_name) as
                            libc::c_long as uint32_t;
                    // Parse a normal node name
                    // TODO - remove.
        // For temporary backward compatibility, handle predicates without the leading '#' sign.
                    if length > 0 as libc::c_int as libc::c_uint &&
                           (*node_name.offset(length.wrapping_sub(1 as
                                                                      libc::c_int
                                                                      as
                                                                      libc::c_uint)
                                                  as isize) as libc::c_int ==
                                '!' as i32 ||
                                *node_name.offset(length.wrapping_sub(1 as
                                                                          libc::c_int
                                                                          as
                                                                          libc::c_uint)
                                                      as isize) as libc::c_int
                                    == '?' as i32) {
                        stream_reset(stream, node_name);
                        return ts_query__parse_predicate(self_0, stream)
                    }
                    symbol =
                        ts_language_symbol_for_name((*self_0).language,
                                                    node_name, length,
                                                    1 as libc::c_int != 0);
                    if symbol == 0 {
                        stream_reset(stream, node_name);
                        return TSQueryErrorNodeType
                    }
                } else { return TSQueryErrorSyntax }
                // Add a step for the node.
                array__grow(&mut (*self_0).steps as *mut C2RustUnnamed_8 as
                                *mut VoidArray, 1 as libc::c_int as size_t,
                            ::std::mem::size_of::<QueryStep>() as
                                libc::c_ulong);
                let fresh15 = (*self_0).steps.size;
                (*self_0).steps.size = (*self_0).steps.size.wrapping_add(1);
                *(*self_0).steps.contents.offset(fresh15 as isize) =
                    query_step__new(symbol, depth as uint16_t, is_immediate);
                // Parse the child patterns
                stream_skip_whitespace(stream);
                let mut child_is_immediate_0: bool = 0 as libc::c_int != 0;
                let mut child_start_step_index: uint16_t =
                    (*self_0).steps.size as uint16_t;
                loop  {
                    if (*stream).next == '.' as i32 {
                        child_is_immediate_0 = 1 as libc::c_int != 0;
                        stream_advance(stream);
                        stream_skip_whitespace(stream);
                    }
                    let mut e_1: TSQueryError =
                        ts_query__parse_pattern(self_0, stream,
                                                depth.wrapping_add(1 as
                                                                       libc::c_int
                                                                       as
                                                                       libc::c_uint),
                                                capture_count,
                                                child_is_immediate_0);
                    if e_1 as libc::c_uint == PARENT_DONE as libc::c_uint &&
                           (*stream).next == ')' as i32 {
                        if child_is_immediate_0 {
                            let ref mut fresh16 =
                                *(*self_0).steps.contents.offset(child_start_step_index
                                                                     as
                                                                     isize);
                            (*fresh16).set_is_last_child(1 as libc::c_int !=
                                                             0)
                        }
                        stream_advance(stream);
                        break ;
                    } else {
                        if e_1 as u64 != 0 { return e_1 }
                        child_is_immediate_0 = 0 as libc::c_int != 0
                    }
                }
            }
        } else if (*stream).next == '_' as i32 || (*stream).next == '*' as i32
         {
            stream_advance(stream);
            stream_skip_whitespace(stream);
            // Parse a wildcard pattern
            // Add a step that matches any kind of node
            array__grow(&mut (*self_0).steps as *mut C2RustUnnamed_8 as
                            *mut VoidArray, 1 as libc::c_int as size_t,
                        ::std::mem::size_of::<QueryStep>() as libc::c_ulong);
            let fresh17 = (*self_0).steps.size;
            (*self_0).steps.size = (*self_0).steps.size.wrapping_add(1);
            *(*self_0).steps.contents.offset(fresh17 as isize) =
                query_step__new(WILDCARD_SYMBOL, depth as uint16_t,
                                is_immediate)
        } else if (*stream).next == '\"' as i32 {
            stream_advance(stream);
            // Parse a double-quoted anonymous leaf node expression
            // Parse the string content
            let mut string_content: *const libc::c_char = (*stream).input;
            while (*stream).next != '\"' as i32 {
                if !stream_advance(stream) {
                    stream_reset(stream,
                                 string_content.offset(-(1 as libc::c_int as
                                                             isize)));
                    return TSQueryErrorSyntax
                }
            }
            let mut length_0: uint32_t =
                (*stream).input.wrapping_offset_from(string_content) as
                    libc::c_long as uint32_t;
            // Add a step for the node
            let mut symbol_0: TSSymbol =
                ts_language_symbol_for_name((*self_0).language,
                                            string_content, length_0,
                                            0 as libc::c_int != 0);
            if symbol_0 == 0 {
                stream_reset(stream, string_content);
                return TSQueryErrorNodeType
            }
            array__grow(&mut (*self_0).steps as *mut C2RustUnnamed_8 as
                            *mut VoidArray, 1 as libc::c_int as size_t,
                        ::std::mem::size_of::<QueryStep>() as libc::c_ulong);
            let fresh18 = (*self_0).steps.size;
            (*self_0).steps.size = (*self_0).steps.size.wrapping_add(1);
            *(*self_0).steps.contents.offset(fresh18 as isize) =
                query_step__new(symbol_0, depth as uint16_t, is_immediate);
            if (*stream).next != '\"' as i32 { return TSQueryErrorSyntax }
            stream_advance(stream);
        } else if stream_is_ident_start(stream) {
            // Parse a field-prefixed pattern
            // Parse the field name
            let mut field_name: *const libc::c_char = (*stream).input;
            stream_scan_identifier(stream);
            let mut length_1: uint32_t =
                (*stream).input.wrapping_offset_from(field_name) as
                    libc::c_long as uint32_t;
            stream_skip_whitespace(stream);
            if (*stream).next != ':' as i32 {
                stream_reset(stream, field_name);
                return TSQueryErrorSyntax
            }
            stream_advance(stream);
            stream_skip_whitespace(stream);
            // Parse the pattern
            let mut step_index_0: uint32_t = (*self_0).steps.size;
            let mut e_2: TSQueryError =
                ts_query__parse_pattern(self_0, stream, depth, capture_count,
                                        is_immediate);
            if e_2 as libc::c_uint == PARENT_DONE as libc::c_uint {
                return TSQueryErrorSyntax
            }
            if e_2 as u64 != 0 { return e_2 }
            // Add the field name to the first step of the pattern
            let mut field_id: TSFieldId =
                ts_language_field_id_for_name((*self_0).language, field_name,
                                              length_1);
            if field_id == 0 {
                (*stream).input = field_name;
                return TSQueryErrorField
            }
            (*(*self_0).steps.contents.offset(step_index_0 as isize)).field =
                field_id
        } else { return TSQueryErrorSyntax }
    }
    stream_skip_whitespace(stream);
    loop 
         // Parse suffixes modifiers for this pattern
         {
        let mut step: *mut QueryStep =
            &mut *(*self_0).steps.contents.offset(starting_step_index as
                                                      isize) as
                *mut QueryStep;
        // Parse the one-or-more operator.
        if (*stream).next == '+' as i32 {
            stream_advance(stream);
            stream_skip_whitespace(stream);
            let mut repeat_step: QueryStep =
                query_step__new(WILDCARD_SYMBOL, depth as uint16_t,
                                0 as libc::c_int != 0);
            repeat_step.alternative_index = starting_step_index as uint16_t;
            repeat_step.set_is_pass_through(1 as libc::c_int != 0);
            repeat_step.set_alternative_is_immediate(1 as libc::c_int != 0);
            array__grow(&mut (*self_0).steps as *mut C2RustUnnamed_8 as
                            *mut VoidArray, 1 as libc::c_int as size_t,
                        ::std::mem::size_of::<QueryStep>() as libc::c_ulong);
            let fresh19 = (*self_0).steps.size;
            (*self_0).steps.size = (*self_0).steps.size.wrapping_add(1);
            *(*self_0).steps.contents.offset(fresh19 as isize) = repeat_step
        } else if (*stream).next == '*' as i32 {
            stream_advance(stream);
            stream_skip_whitespace(stream);
            let mut repeat_step_0: QueryStep =
                query_step__new(WILDCARD_SYMBOL, depth as uint16_t,
                                0 as libc::c_int != 0);
            repeat_step_0.alternative_index = starting_step_index as uint16_t;
            repeat_step_0.set_is_pass_through(1 as libc::c_int != 0);
            repeat_step_0.set_alternative_is_immediate(1 as libc::c_int != 0);
            array__grow(&mut (*self_0).steps as *mut C2RustUnnamed_8 as
                            *mut VoidArray, 1 as libc::c_int as size_t,
                        ::std::mem::size_of::<QueryStep>() as libc::c_ulong);
            let fresh20 = (*self_0).steps.size;
            (*self_0).steps.size = (*self_0).steps.size.wrapping_add(1);
            *(*self_0).steps.contents.offset(fresh20 as isize) =
                repeat_step_0;
            while (*step).alternative_index as libc::c_int !=
                      NONE as libc::c_int {
                step =
                    &mut *(*self_0).steps.contents.offset((*step).alternative_index
                                                              as isize) as
                        *mut QueryStep
            }
            (*step).alternative_index = (*self_0).steps.size as uint16_t
        } else if (*stream).next == '?' as i32 {
            stream_advance(stream);
            stream_skip_whitespace(stream);
            while (*step).alternative_index as libc::c_int !=
                      NONE as libc::c_int {
                step =
                    &mut *(*self_0).steps.contents.offset((*step).alternative_index
                                                              as isize) as
                        *mut QueryStep
            }
            (*step).alternative_index = (*self_0).steps.size as uint16_t
        } else {
            // Parse the zero-or-more repetition operator.
            // Parse the optional operator.
            // Parse an '@'-prefixed capture pattern
            if !((*stream).next == '@' as i32) { break ; }
            stream_advance(stream);
            if !stream_is_ident_start(stream) { return TSQueryErrorSyntax }
            let mut capture_name: *const libc::c_char = (*stream).input;
            stream_scan_identifier(stream);
            let mut length_2: uint32_t =
                (*stream).input.wrapping_offset_from(capture_name) as
                    libc::c_long as uint32_t;
            stream_skip_whitespace(stream);
            // Add the capture id to the first step of the pattern
            let mut capture_id: uint16_t =
                symbol_table_insert_name(&mut (*self_0).captures,
                                         capture_name, length_2);
            loop  {
                query_step__add_capture(step, capture_id);
                if !((*step).alternative_index as libc::c_int !=
                         NONE as libc::c_int &&
                         (*step).alternative_index as libc::c_uint >
                             starting_step_index &&
                         ((*step).alternative_index as libc::c_uint) <
                             (*self_0).steps.size) {
                    break ;
                }
                starting_step_index = (*step).alternative_index as uint32_t;
                step =
                    &mut *(*self_0).steps.contents.offset(starting_step_index
                                                              as isize) as
                        *mut QueryStep
            }
            *capture_count = (*capture_count).wrapping_add(1)
        }
    }
    return TSQueryErrorNone;
}
#[no_mangle]
pub unsafe extern "C" fn ts_query_new(mut language: *const TSLanguage,
                                      mut source: *const libc::c_char,
                                      mut source_len: uint32_t,
                                      mut error_offset: *mut uint32_t,
                                      mut error_type: *mut TSQueryError)
 -> *mut TSQuery {
    let mut symbol_map: *mut TSSymbol = 0 as *mut TSSymbol;
    if ts_language_version(language) >= 11 as libc::c_int as libc::c_uint {
        symbol_map = 0 as *mut TSSymbol
    } else {
        // Work around the fact that multiple symbols can currently be
    // associated with the same name, due to "simple aliases".
    // In the next language ABI version, this map will be contained
    // in the language's `public_symbol_map` field.
        let mut symbol_count: uint32_t = ts_language_symbol_count(language);
        symbol_map =
            ts_malloc((::std::mem::size_of::<TSSymbol>() as
                           libc::c_ulong).wrapping_mul(symbol_count as
                                                           libc::c_ulong)) as
                *mut TSSymbol;
        let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
        while i < symbol_count {
            let mut name: *const libc::c_char =
                ts_language_symbol_name(language, i as TSSymbol);
            let symbol_type: TSSymbolType =
                ts_language_symbol_type(language, i as TSSymbol);
            *symbol_map.offset(i as isize) = i as TSSymbol;
            let mut j: libc::c_uint = 0 as libc::c_int as libc::c_uint;
            while j < i {
                if ts_language_symbol_type(language, j as TSSymbol) as
                       libc::c_uint == symbol_type as libc::c_uint {
                    if strcmp(name,
                              ts_language_symbol_name(language,
                                                      j as TSSymbol)) == 0 {
                        *symbol_map.offset(i as isize) = j as TSSymbol;
                        break ;
                    }
                }
                j = j.wrapping_add(1)
            }
            i = i.wrapping_add(1)
        }
    }
    let mut self_0: *mut TSQuery =
        ts_malloc(::std::mem::size_of::<TSQuery>() as libc::c_ulong) as
            *mut TSQuery;
    *self_0 =
        {
            let mut init =
                TSQuery{captures: symbol_table_new(),
                        predicate_values: symbol_table_new(),
                        steps:
                            {
                                let mut init =
                                    C2RustUnnamed_8{contents:
                                                        0 as *mut QueryStep,
                                                    size:
                                                        0 as libc::c_int as
                                                            uint32_t,
                                                    capacity:
                                                        0 as libc::c_int as
                                                            uint32_t,};
                                init
                            },
                        pattern_map:
                            {
                                let mut init =
                                    C2RustUnnamed_7{contents:
                                                        0 as
                                                            *mut PatternEntry,
                                                    size:
                                                        0 as libc::c_int as
                                                            uint32_t,
                                                    capacity:
                                                        0 as libc::c_int as
                                                            uint32_t,};
                                init
                            },
                        predicate_steps:
                            {
                                let mut init =
                                    C2RustUnnamed_6{contents:
                                                        0 as
                                                            *mut TSQueryPredicateStep,
                                                    size:
                                                        0 as libc::c_int as
                                                            uint32_t,
                                                    capacity:
                                                        0 as libc::c_int as
                                                            uint32_t,};
                                init
                            },
                        predicates_by_pattern:
                            {
                                let mut init =
                                    C2RustUnnamed_5{contents: 0 as *mut Slice,
                                                    size:
                                                        0 as libc::c_int as
                                                            uint32_t,
                                                    capacity:
                                                        0 as libc::c_int as
                                                            uint32_t,};
                                init
                            },
                        start_bytes_by_pattern:
                            C2RustUnnamed_4{contents: 0 as *mut uint32_t,
                                            size: 0,
                                            capacity: 0,},
                        language: language,
                        wildcard_root_pattern_count:
                            0 as libc::c_int as uint16_t,
                        symbol_map: symbol_map,};
            init
        };
    // Parse all of the S-expressions in the given string.
    let mut stream: Stream = stream_new(source, source_len);
    stream_skip_whitespace(&mut stream);
    while stream.input < stream.end {
        let mut pattern_index: uint32_t =
            (*self_0).predicates_by_pattern.size;
        let mut start_step_index: uint32_t = (*self_0).steps.size;
        let mut capture_count: uint32_t = 0 as libc::c_int as uint32_t;
        array__grow(&mut (*self_0).start_bytes_by_pattern as
                        *mut C2RustUnnamed_4 as *mut VoidArray,
                    1 as libc::c_int as size_t,
                    ::std::mem::size_of::<uint32_t>() as libc::c_ulong);
        let fresh21 = (*self_0).start_bytes_by_pattern.size;
        (*self_0).start_bytes_by_pattern.size =
            (*self_0).start_bytes_by_pattern.size.wrapping_add(1);
        *(*self_0).start_bytes_by_pattern.contents.offset(fresh21 as isize) =
            stream.input.wrapping_offset_from(source) as libc::c_long as
                uint32_t;
        array__grow(&mut (*self_0).predicates_by_pattern as
                        *mut C2RustUnnamed_5 as *mut VoidArray,
                    1 as libc::c_int as size_t,
                    ::std::mem::size_of::<Slice>() as libc::c_ulong);
        let fresh22 = (*self_0).predicates_by_pattern.size;
        (*self_0).predicates_by_pattern.size =
            (*self_0).predicates_by_pattern.size.wrapping_add(1);
        *(*self_0).predicates_by_pattern.contents.offset(fresh22 as isize) =
            {
                let mut init =
                    Slice{offset: (*self_0).predicate_steps.size,
                          length: 0 as libc::c_int as uint32_t,};
                init
            };
        *error_type =
            ts_query__parse_pattern(self_0, &mut stream,
                                    0 as libc::c_int as uint32_t,
                                    &mut capture_count,
                                    0 as libc::c_int != 0);
        array__grow(&mut (*self_0).steps as *mut C2RustUnnamed_8 as
                        *mut VoidArray, 1 as libc::c_int as size_t,
                    ::std::mem::size_of::<QueryStep>() as libc::c_ulong);
        let fresh23 = (*self_0).steps.size;
        (*self_0).steps.size = (*self_0).steps.size.wrapping_add(1);
        *(*self_0).steps.contents.offset(fresh23 as isize) =
            query_step__new(0 as libc::c_int as TSSymbol, PATTERN_DONE_MARKER,
                            0 as libc::c_int != 0);
        // If any pattern could not be parsed, then report the error information
    // and terminate.
        if *error_type as u64 != 0 {
            if *error_type as libc::c_uint == PARENT_DONE as libc::c_uint {
                *error_type = TSQueryErrorSyntax
            }
            *error_offset =
                stream.input.wrapping_offset_from(source) as libc::c_long as
                    uint32_t;
            ts_query_delete(self_0);
            return 0 as *mut TSQuery
        }
        // If a pattern has a wildcard at its root, optimize the matching process
    // by skipping matching the wildcard.
        if (*(*self_0).steps.contents.offset(start_step_index as
                                                 isize)).symbol as libc::c_int
               == WILDCARD_SYMBOL as libc::c_int {
            let mut second_step: *mut QueryStep =
                &mut *(*self_0).steps.contents.offset(start_step_index.wrapping_add(1
                                                                                        as
                                                                                        libc::c_int
                                                                                        as
                                                                                        libc::c_uint)
                                                          as isize) as
                    *mut QueryStep;
            if (*second_step).symbol as libc::c_int !=
                   WILDCARD_SYMBOL as libc::c_int &&
                   (*second_step).depth as libc::c_int !=
                       PATTERN_DONE_MARKER as libc::c_int {
                start_step_index =
                    (start_step_index as
                         libc::c_uint).wrapping_add(1 as libc::c_int as
                                                        libc::c_uint) as
                        uint32_t as uint32_t
            }
        }
        loop 
             // Maintain a map that can look up patterns for a given root symbol.
             {
            let mut step: *mut QueryStep =
                &mut *(*self_0).steps.contents.offset(start_step_index as
                                                          isize) as
                    *mut QueryStep;
            (*step).set_is_pattern_start(1 as libc::c_int != 0);
            ts_query__pattern_map_insert(self_0, (*step).symbol,
                                         start_step_index, pattern_index);
            if (*step).symbol as libc::c_int == WILDCARD_SYMBOL as libc::c_int
               {
                (*self_0).wildcard_root_pattern_count =
                    (*self_0).wildcard_root_pattern_count.wrapping_add(1)
            }
            // If there are alternatives or options at the root of the pattern,
      // then add multiple entries to the pattern map.
            if !((*step).alternative_index as libc::c_int !=
                     NONE as libc::c_int) {
                break ;
            }
            start_step_index = (*step).alternative_index as uint32_t
        }
    }
    ts_query__finalize_steps(self_0);
    return self_0;
}
#[no_mangle]
pub unsafe extern "C" fn ts_query_delete(mut self_0: *mut TSQuery) {
    if !self_0.is_null() {
        array__delete(&mut (*self_0).steps as *mut C2RustUnnamed_8 as
                          *mut VoidArray);
        array__delete(&mut (*self_0).pattern_map as *mut C2RustUnnamed_7 as
                          *mut VoidArray);
        array__delete(&mut (*self_0).predicate_steps as *mut C2RustUnnamed_6
                          as *mut VoidArray);
        array__delete(&mut (*self_0).predicates_by_pattern as
                          *mut C2RustUnnamed_5 as *mut VoidArray);
        array__delete(&mut (*self_0).start_bytes_by_pattern as
                          *mut C2RustUnnamed_4 as *mut VoidArray);
        symbol_table_delete(&mut (*self_0).captures);
        symbol_table_delete(&mut (*self_0).predicate_values);
        ts_free((*self_0).symbol_map as *mut libc::c_void);
        ts_free(self_0 as *mut libc::c_void);
    };
}
#[no_mangle]
pub unsafe extern "C" fn ts_query_pattern_count(mut self_0: *const TSQuery)
 -> uint32_t {
    return (*self_0).predicates_by_pattern.size;
}
#[no_mangle]
pub unsafe extern "C" fn ts_query_capture_count(mut self_0: *const TSQuery)
 -> uint32_t {
    return (*self_0).captures.slices.size;
}
#[no_mangle]
pub unsafe extern "C" fn ts_query_string_count(mut self_0: *const TSQuery)
 -> uint32_t {
    return (*self_0).predicate_values.slices.size;
}
#[no_mangle]
pub unsafe extern "C" fn ts_query_capture_name_for_id(mut self_0:
                                                          *const TSQuery,
                                                      mut index: uint32_t,
                                                      mut length:
                                                          *mut uint32_t)
 -> *const libc::c_char {
    return symbol_table_name_for_id(&(*self_0).captures, index as uint16_t,
                                    length);
}
#[no_mangle]
pub unsafe extern "C" fn ts_query_string_value_for_id(mut self_0:
                                                          *const TSQuery,
                                                      mut index: uint32_t,
                                                      mut length:
                                                          *mut uint32_t)
 -> *const libc::c_char {
    return symbol_table_name_for_id(&(*self_0).predicate_values,
                                    index as uint16_t, length);
}
#[no_mangle]
pub unsafe extern "C" fn ts_query_predicates_for_pattern(mut self_0:
                                                             *const TSQuery,
                                                         mut pattern_index:
                                                             uint32_t,
                                                         mut step_count:
                                                             *mut uint32_t)
 -> *const TSQueryPredicateStep {
    let mut slice: Slice =
        *(*self_0).predicates_by_pattern.contents.offset(pattern_index as
                                                             isize);
    *step_count = slice.length;
    return &mut *(*self_0).predicate_steps.contents.offset(slice.offset as
                                                               isize) as
               *mut TSQueryPredicateStep;
}
#[no_mangle]
pub unsafe extern "C" fn ts_query_start_byte_for_pattern(mut self_0:
                                                             *const TSQuery,
                                                         mut pattern_index:
                                                             uint32_t)
 -> uint32_t {
    return *(*self_0).start_bytes_by_pattern.contents.offset(pattern_index as
                                                                 isize);
}
#[no_mangle]
pub unsafe extern "C" fn ts_query_disable_capture(mut self_0: *mut TSQuery,
                                                  mut name:
                                                      *const libc::c_char,
                                                  mut length: uint32_t) {
    // Remove capture information for any pattern step that previously
  // captured with the given name.
    let mut id: libc::c_int =
        symbol_table_id_for_name(&mut (*self_0).captures, name, length);
    if id != -(1 as libc::c_int) {
        let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
        while i < (*self_0).steps.size {
            let mut step: *mut QueryStep =
                &mut *(*self_0).steps.contents.offset(i as isize) as
                    *mut QueryStep;
            query_step__remove_capture(step, id as uint16_t);
            i = i.wrapping_add(1)
        }
        ts_query__finalize_steps(self_0);
    };
}
#[no_mangle]
pub unsafe extern "C" fn ts_query_disable_pattern(mut self_0: *mut TSQuery,
                                                  mut pattern_index:
                                                      uint32_t) {
    // Remove the given pattern from the pattern map. Its steps will still
  // be in the `steps` array, but they will never be read.
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    while i < (*self_0).pattern_map.size {
        let mut pattern: *mut PatternEntry =
            &mut *(*self_0).pattern_map.contents.offset(i as isize) as
                *mut PatternEntry;
        if (*pattern).pattern_index as libc::c_uint == pattern_index {
            array__erase(&mut (*self_0).pattern_map as *mut C2RustUnnamed_7 as
                             *mut VoidArray,
                         ::std::mem::size_of::<PatternEntry>() as
                             libc::c_ulong, i);
            i = i.wrapping_sub(1)
        }
        i = i.wrapping_add(1)
    };
}
/* **************
 * QueryCursor
 ***************/
#[no_mangle]
pub unsafe extern "C" fn ts_query_cursor_new() -> *mut TSQueryCursor {
    let mut self_0: *mut TSQueryCursor =
        ts_malloc(::std::mem::size_of::<TSQueryCursor>() as libc::c_ulong) as
            *mut TSQueryCursor;
    *self_0 =
        {
            let mut init =
                TSQueryCursor{query: 0 as *const TSQuery,
                              cursor:
                                  TSTreeCursor{tree: 0 as *const libc::c_void,
                                               id: 0 as *const libc::c_void,
                                               context: [0; 2],},
                              states:
                                  {
                                      let mut init =
                                          C2RustUnnamed_12{contents:
                                                               0 as
                                                                   *mut QueryState,
                                                           size:
                                                               0 as
                                                                   libc::c_int
                                                                   as
                                                                   uint32_t,
                                                           capacity:
                                                               0 as
                                                                   libc::c_int
                                                                   as
                                                                   uint32_t,};
                                      init
                                  },
                              finished_states:
                                  {
                                      let mut init =
                                          C2RustUnnamed_11{contents:
                                                               0 as
                                                                   *mut QueryState,
                                                           size:
                                                               0 as
                                                                   libc::c_int
                                                                   as
                                                                   uint32_t,
                                                           capacity:
                                                               0 as
                                                                   libc::c_int
                                                                   as
                                                                   uint32_t,};
                                      init
                                  },
                              capture_list_pool: capture_list_pool_new(),
                              depth: 0,
                              start_byte: 0 as libc::c_int as uint32_t,
                              end_byte: 4294967295 as libc::c_uint,
                              next_state_id: 0,
                              start_point:
                                  {
                                      let mut init =
                                          TSPoint{row:
                                                      0 as libc::c_int as
                                                          uint32_t,
                                                  column:
                                                      0 as libc::c_int as
                                                          uint32_t,};
                                      init
                                  },
                              end_point:
                                  {
                                      let mut init =
                                          TSPoint{row:
                                                      4294967295 as
                                                          libc::c_uint,
                                                  column:
                                                      4294967295 as
                                                          libc::c_uint,};
                                      init
                                  },
                              ascending: 0 as libc::c_int != 0,};
            init
        };
    array__reserve(&mut (*self_0).states as *mut C2RustUnnamed_12 as
                       *mut VoidArray,
                   ::std::mem::size_of::<QueryState>() as libc::c_ulong,
                   256 as libc::c_int as uint32_t);
    array__reserve(&mut (*self_0).finished_states as *mut C2RustUnnamed_11 as
                       *mut VoidArray,
                   ::std::mem::size_of::<QueryState>() as libc::c_ulong,
                   32 as libc::c_int as uint32_t);
    return self_0;
}
#[no_mangle]
pub unsafe extern "C" fn ts_query_cursor_delete(mut self_0:
                                                    *mut TSQueryCursor) {
    array__delete(&mut (*self_0).states as *mut C2RustUnnamed_12 as
                      *mut VoidArray);
    array__delete(&mut (*self_0).finished_states as *mut C2RustUnnamed_11 as
                      *mut VoidArray);
    ts_tree_cursor_delete(&mut (*self_0).cursor);
    capture_list_pool_delete(&mut (*self_0).capture_list_pool);
    ts_free(self_0 as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn ts_query_cursor_exec(mut self_0: *mut TSQueryCursor,
                                              mut query: *const TSQuery,
                                              mut node: TSNode) {
    (*self_0).states.size = 0 as libc::c_int as uint32_t;
    (*self_0).finished_states.size = 0 as libc::c_int as uint32_t;
    ts_tree_cursor_reset(&mut (*self_0).cursor, node);
    capture_list_pool_reset(&mut (*self_0).capture_list_pool);
    (*self_0).next_state_id = 0 as libc::c_int as uint32_t;
    (*self_0).depth = 0 as libc::c_int as uint32_t;
    (*self_0).ascending = 0 as libc::c_int != 0;
    (*self_0).query = query;
}
#[no_mangle]
pub unsafe extern "C" fn ts_query_cursor_set_byte_range(mut self_0:
                                                            *mut TSQueryCursor,
                                                        mut start_byte:
                                                            uint32_t,
                                                        mut end_byte:
                                                            uint32_t) {
    if end_byte == 0 as libc::c_int as libc::c_uint {
        start_byte = 0 as libc::c_int as uint32_t;
        end_byte = 4294967295 as libc::c_uint
    }
    (*self_0).start_byte = start_byte;
    (*self_0).end_byte = end_byte;
}
#[no_mangle]
pub unsafe extern "C" fn ts_query_cursor_set_point_range(mut self_0:
                                                             *mut TSQueryCursor,
                                                         mut start_point:
                                                             TSPoint,
                                                         mut end_point:
                                                             TSPoint) {
    if end_point.row == 0 as libc::c_int as libc::c_uint &&
           end_point.column == 0 as libc::c_int as libc::c_uint {
        start_point =
            {
                let mut init =
                    TSPoint{row: 0 as libc::c_int as uint32_t,
                            column: 0 as libc::c_int as uint32_t,};
                init
            };
        end_point =
            {
                let mut init =
                    TSPoint{row: 4294967295 as libc::c_uint,
                            column: 4294967295 as libc::c_uint,};
                init
            }
    }
    (*self_0).start_point = start_point;
    (*self_0).end_point = end_point;
}
// Search through all of the in-progress states, and find the captured
// node that occurs earliest in the document.
unsafe extern "C" fn ts_query_cursor__first_in_progress_capture(mut self_0:
                                                                    *mut TSQueryCursor,
                                                                mut state_index:
                                                                    *mut uint32_t,
                                                                mut byte_offset:
                                                                    *mut uint32_t,
                                                                mut pattern_index:
                                                                    *mut uint32_t)
 -> bool {
    let mut result: bool = 0 as libc::c_int != 0;
    *state_index = 4294967295 as libc::c_uint;
    *byte_offset = 4294967295 as libc::c_uint;
    *pattern_index = 4294967295 as libc::c_uint;
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    while i < (*self_0).states.size {
        let mut state: *const QueryState =
            &mut *(*self_0).states.contents.offset(i as isize) as
                *mut QueryState;
        let mut captures: *const CaptureList =
            capture_list_pool_get(&mut (*self_0).capture_list_pool,
                                  (*state).capture_list_id);
        if (*captures).size > 0 as libc::c_int as libc::c_uint {
            let mut capture_byte: uint32_t =
                ts_node_start_byte((*(*captures).contents.offset(0 as
                                                                     libc::c_int
                                                                     as
                                                                     isize)).node);
            if !result || capture_byte < *byte_offset ||
                   capture_byte == *byte_offset &&
                       ((*state).pattern_index as libc::c_uint) <
                           *pattern_index {
                result = 1 as libc::c_int != 0;
                *state_index = i;
                *byte_offset = capture_byte;
                *pattern_index = (*state).pattern_index as uint32_t
            }
        }
        i = i.wrapping_add(1)
    }
    return result;
}
// Determine which node is first in a depth-first traversal
#[no_mangle]
pub unsafe extern "C" fn ts_query_cursor__compare_nodes(mut left: TSNode,
                                                        mut right: TSNode)
 -> libc::c_int {
    if left.id != right.id {
        let mut left_start: uint32_t = ts_node_start_byte(left);
        let mut right_start: uint32_t = ts_node_start_byte(right);
        if left_start < right_start { return -(1 as libc::c_int) }
        if left_start > right_start { return 1 as libc::c_int }
        let mut left_node_count: uint32_t = ts_node_end_byte(left);
        let mut right_node_count: uint32_t = ts_node_end_byte(right);
        if left_node_count > right_node_count { return -(1 as libc::c_int) }
        if left_node_count < right_node_count { return 1 as libc::c_int }
    }
    return 0 as libc::c_int;
}
// Determine if either state contains a superset of the other state's captures.
#[no_mangle]
pub unsafe extern "C" fn ts_query_cursor__compare_captures(mut self_0:
                                                               *mut TSQueryCursor,
                                                           mut left_state:
                                                               *mut QueryState,
                                                           mut right_state:
                                                               *mut QueryState,
                                                           mut left_contains_right:
                                                               *mut bool,
                                                           mut right_contains_left:
                                                               *mut bool) {
    let mut left_captures: *const CaptureList =
        capture_list_pool_get(&mut (*self_0).capture_list_pool,
                              (*left_state).capture_list_id);
    let mut right_captures: *const CaptureList =
        capture_list_pool_get(&mut (*self_0).capture_list_pool,
                              (*right_state).capture_list_id);
    *left_contains_right = 1 as libc::c_int != 0;
    *right_contains_left = 1 as libc::c_int != 0;
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut j: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    loop  {
        if i < (*left_captures).size {
            if j < (*right_captures).size {
                let mut left: *mut TSQueryCapture =
                    &mut *(*left_captures).contents.offset(i as isize) as
                        *mut TSQueryCapture;
                let mut right: *mut TSQueryCapture =
                    &mut *(*right_captures).contents.offset(j as isize) as
                        *mut TSQueryCapture;
                if (*left).node.id == (*right).node.id &&
                       (*left).index == (*right).index {
                    i = i.wrapping_add(1);
                    j = j.wrapping_add(1)
                } else {
                    match ts_query_cursor__compare_nodes((*left).node,
                                                         (*right).node) {
                        -1 => {
                            *right_contains_left = 0 as libc::c_int != 0;
                            i = i.wrapping_add(1)
                        }
                        1 => {
                            *left_contains_right = 0 as libc::c_int != 0;
                            j = j.wrapping_add(1)
                        }
                        _ => {
                            *right_contains_left = 0 as libc::c_int != 0;
                            *left_contains_right = 0 as libc::c_int != 0;
                            i = i.wrapping_add(1);
                            j = j.wrapping_add(1)
                        }
                    }
                }
            } else { *right_contains_left = 0 as libc::c_int != 0; break ; }
        } else {
            if j < (*right_captures).size {
                *left_contains_right = 0 as libc::c_int != 0
            }
            break ;
        }
    };
}
unsafe extern "C" fn ts_query_cursor__add_state(mut self_0:
                                                    *mut TSQueryCursor,
                                                mut pattern:
                                                    *const PatternEntry)
 -> bool {
    if (*self_0).states.size >= 256 as libc::c_int as libc::c_uint {
        return 0 as libc::c_int != 0
    }
    let mut step: *mut QueryStep =
        &mut *(*(*self_0).query).steps.contents.offset((*pattern).step_index
                                                           as isize) as
            *mut QueryStep;
    array__grow(&mut (*self_0).states as *mut C2RustUnnamed_12 as
                    *mut VoidArray, 1 as libc::c_int as size_t,
                ::std::mem::size_of::<QueryState>() as libc::c_ulong);
    let fresh24 = (*self_0).states.size;
    (*self_0).states.size = (*self_0).states.size.wrapping_add(1);
    *(*self_0).states.contents.offset(fresh24 as isize) =
        {
            let mut init =
                QueryState{consumed_capture_count_seeking_immediate_match_has_in_progress_alternatives:
                               [0; 2],
                           c2rust_padding: [0; 2],
                           id: 0,
                           start_depth:
                               (*self_0).depth.wrapping_sub((*step).depth as
                                                                libc::c_uint)
                                   as uint16_t,
                           step_index: (*pattern).step_index,
                           pattern_index: (*pattern).pattern_index,
                           capture_list_id: NONE,};
            init.set_consumed_capture_count(0 as libc::c_int as uint16_t);
            init.set_seeking_immediate_match(0 as libc::c_int != 0);
            init.set_has_in_progress_alternatives(false);
            init
        };
    return 1 as libc::c_int != 0;
}
// Duplicate the given state and insert the newly-created state immediately after
// the given state in the `states` array.
unsafe extern "C" fn ts_query__cursor_copy_state(mut self_0:
                                                     *mut TSQueryCursor,
                                                 mut state: *const QueryState)
 -> *mut QueryState {
    if (*self_0).states.size >= 256 as libc::c_int as libc::c_uint {
        return 0 as *mut QueryState
    }
    // If the state has captures, copy its capture list.
    let mut copy: QueryState = *state;
    copy.capture_list_id = (*state).capture_list_id;
    if (*state).capture_list_id as libc::c_int != NONE as libc::c_int {
        copy.capture_list_id =
            capture_list_pool_acquire(&mut (*self_0).capture_list_pool);
        if copy.capture_list_id as libc::c_int == NONE as libc::c_int {
            return 0 as *mut QueryState
        }
        let mut old_captures: *const CaptureList =
            capture_list_pool_get(&mut (*self_0).capture_list_pool,
                                  (*state).capture_list_id);
        let mut new_captures: *mut CaptureList =
            capture_list_pool_get_mut(&mut (*self_0).capture_list_pool,
                                      copy.capture_list_id);
        array__splice(new_captures as *mut VoidArray,
                      ::std::mem::size_of::<TSQueryCapture>() as
                          libc::c_ulong, (*new_captures).size,
                      0 as libc::c_int as uint32_t, (*old_captures).size,
                      (*old_captures).contents as *const libc::c_void);
    }
    let mut index: uint32_t =
        (state.wrapping_offset_from((*self_0).states.contents) as libc::c_long
             + 1 as libc::c_int as libc::c_long) as uint32_t;
    array__splice(&mut (*self_0).states as *mut C2RustUnnamed_12 as
                      *mut VoidArray,
                  ::std::mem::size_of::<QueryState>() as libc::c_ulong, index,
                  0 as libc::c_int as uint32_t, 1 as libc::c_int as uint32_t,
                  &mut copy as *mut QueryState as *const libc::c_void);
    return &mut *(*self_0).states.contents.offset(index as isize) as
               *mut QueryState;
}
// Walk the tree, processing patterns until at least one pattern finishes,
// If one or more patterns finish, return `true` and store their states in the
// `finished_states` array. Multiple patterns can finish on the same node. If
// there are no more matches, return `false`.
#[inline]
unsafe extern "C" fn ts_query_cursor__advance(mut self_0: *mut TSQueryCursor)
 -> bool {
    loop  {
        if (*self_0).ascending {
            // Leave this node by stepping to its next sibling or to its parent.
            let mut did_move: bool = 1 as libc::c_int != 0;
            if ts_tree_cursor_goto_next_sibling(&mut (*self_0).cursor) {
                (*self_0).ascending = 0 as libc::c_int != 0
            } else if ts_tree_cursor_goto_parent(&mut (*self_0).cursor) {
                (*self_0).depth = (*self_0).depth.wrapping_sub(1)
            } else { did_move = 0 as libc::c_int != 0 }
            // After leaving a node, remove any states that cannot make further progress.
            let mut deleted_count: uint32_t = 0 as libc::c_int as uint32_t;
            let mut current_block_18: u64;
            let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
            let mut n: libc::c_uint = (*self_0).states.size;
            while i < n {
                let mut state: *mut QueryState =
                    &mut *(*self_0).states.contents.offset(i as isize) as
                        *mut QueryState;
                let mut step: *mut QueryStep =
                    &mut *(*(*self_0).query).steps.contents.offset((*state).step_index
                                                                       as
                                                                       isize)
                        as *mut QueryStep;
                // If a state completed its pattern inside of this node, but was deferred from finishing
        // in order to search for longer matches, mark it as finished.
                if (*step).depth as libc::c_int ==
                       PATTERN_DONE_MARKER as libc::c_int {
                    if (*state).start_depth as libc::c_uint > (*self_0).depth
                           || !did_move {
                        let fresh25 = (*self_0).next_state_id;
                        (*self_0).next_state_id =
                            (*self_0).next_state_id.wrapping_add(1);
                        (*state).id = fresh25;
                        array__grow(&mut (*self_0).finished_states as
                                        *mut C2RustUnnamed_11 as
                                        *mut VoidArray,
                                    1 as libc::c_int as size_t,
                                    ::std::mem::size_of::<QueryState>() as
                                        libc::c_ulong);
                        let fresh26 = (*self_0).finished_states.size;
                        (*self_0).finished_states.size =
                            (*self_0).finished_states.size.wrapping_add(1);
                        *(*self_0).finished_states.contents.offset(fresh26 as
                                                                       isize)
                            = *state;
                        deleted_count = deleted_count.wrapping_add(1);
                        current_block_18 = 5399440093318478209;
                    } else { current_block_18 = 15768484401365413375; }
                } else if ((*state).start_depth as
                               uint32_t).wrapping_add((*step).depth as
                                                          uint32_t) >
                              (*self_0).depth {
                    capture_list_pool_release(&mut (*self_0).capture_list_pool,
                                              (*state).capture_list_id);
                    deleted_count = deleted_count.wrapping_add(1);
                    current_block_18 = 5399440093318478209;
                } else { current_block_18 = 15768484401365413375; }
                match current_block_18 {
                    15768484401365413375 => {
                        if deleted_count > 0 as libc::c_int as libc::c_uint {
                            *(*self_0).states.contents.offset(i.wrapping_sub(deleted_count)
                                                                  as isize) =
                                *state
                        }
                    }
                    _ => { }
                }
                i = i.wrapping_add(1)
            }
            (*self_0).states.size =
                ((*self_0).states.size as
                     libc::c_uint).wrapping_sub(deleted_count) as uint32_t as
                    uint32_t;
            if !did_move {
                return (*self_0).finished_states.size >
                           0 as libc::c_int as libc::c_uint
            }
        } else {
            // If a state needed to match something within this node, then remove that state
        // as it has failed to match.
            // If this node is before the selected range, then avoid descending into it.
            let mut node: TSNode =
                ts_tree_cursor_current_node(&mut (*self_0).cursor);
            if ts_node_end_byte(node) <= (*self_0).start_byte ||
                   point_lte(ts_node_end_point(node), (*self_0).start_point)
                       as libc::c_int != 0 {
                if !ts_tree_cursor_goto_next_sibling(&mut (*self_0).cursor) {
                    (*self_0).ascending = 1 as libc::c_int != 0
                }
            } else {
                // If this node is after the selected range, then stop walking.
                if (*self_0).end_byte <= ts_node_start_byte(node) ||
                       point_lte((*self_0).end_point,
                                 ts_node_start_point(node)) as libc::c_int !=
                           0 {
                    return 0 as libc::c_int != 0
                }
                // Get the properties of the current node.
                let mut symbol: TSSymbol = ts_node_symbol(node);
                let mut is_named: bool = ts_node_is_named(node);
                if symbol as libc::c_int !=
                       -(1 as libc::c_int) as TSSymbol as libc::c_int &&
                       !(*(*self_0).query).symbol_map.is_null() {
                    symbol =
                        *(*(*self_0).query).symbol_map.offset(symbol as isize)
                }
                let mut can_have_later_siblings: bool = false;
                let mut can_have_later_siblings_with_this_field: bool = false;
                let mut field_id: TSFieldId =
                    ts_tree_cursor_current_status(&mut (*self_0).cursor,
                                                  &mut can_have_later_siblings,
                                                  &mut can_have_later_siblings_with_this_field);
                // Add new states for any patterns whose root node is a wildcard.
                let mut i_0: libc::c_uint = 0 as libc::c_int as libc::c_uint;
                while i_0 <
                          (*(*self_0).query).wildcard_root_pattern_count as
                              libc::c_uint {
                    let mut pattern: *mut PatternEntry =
                        &mut *(*(*self_0).query).pattern_map.contents.offset(i_0
                                                                                 as
                                                                                 isize)
                            as *mut PatternEntry;
                    let mut step_0: *mut QueryStep =
                        &mut *(*(*self_0).query).steps.contents.offset((*pattern).step_index
                                                                           as
                                                                           isize)
                            as *mut QueryStep;
                    // If this node matches the first step of the pattern, then add a new
        // state at the start of this pattern.
                    if !((*step_0).field as libc::c_int != 0 &&
                             field_id as libc::c_int !=
                                 (*step_0).field as libc::c_int) {
                        if !ts_query_cursor__add_state(self_0, pattern) {
                            break ;
                        }
                    }
                    i_0 = i_0.wrapping_add(1)
                }
                // Add new states for any patterns whose root node matches this node.
                let mut i_1: libc::c_uint = 0;
                if ts_query__pattern_map_search((*self_0).query, symbol,
                                                &mut i_1) {
                    let mut pattern_0: *mut PatternEntry =
                        &mut *(*(*self_0).query).pattern_map.contents.offset(i_1
                                                                                 as
                                                                                 isize)
                            as *mut PatternEntry;
                    let mut step_1: *mut QueryStep =
                        &mut *(*(*self_0).query).steps.contents.offset((*pattern_0).step_index
                                                                           as
                                                                           isize)
                            as *mut QueryStep;
                    loop 
                         // If this node matches the first step of the pattern, then add a new
          // state at the start of this pattern.
                         {
                        if !((*step_1).field as libc::c_int != 0 &&
                                 field_id as libc::c_int !=
                                     (*step_1).field as libc::c_int) {
                            if !ts_query_cursor__add_state(self_0, pattern_0)
                               {
                                break ;
                            }
                            // Advance to the next pattern whose root node matches this node.
                            i_1 = i_1.wrapping_add(1);
                            if i_1 == (*(*self_0).query).pattern_map.size {
                                break ;
                            }
                            pattern_0 =
                                &mut *(*(*self_0).query).pattern_map.contents.offset(i_1
                                                                                         as
                                                                                         isize)
                                    as *mut PatternEntry;
                            step_1 =
                                &mut *(*(*self_0).query).steps.contents.offset((*pattern_0).step_index
                                                                                   as
                                                                                   isize)
                                    as *mut QueryStep
                        }
                        if !((*step_1).symbol as libc::c_int ==
                                 symbol as libc::c_int) {
                            break ;
                        }
                    }
                }
                let mut current_block_103: u64;
                // Update all of the in-progress states with current node.
                let mut i_2: libc::c_uint = 0 as libc::c_int as libc::c_uint;
                let mut copy_count: libc::c_uint =
                    0 as libc::c_int as libc::c_uint;
                while i_2 < (*self_0).states.size {
                    let mut state_0: *mut QueryState =
                        &mut *(*self_0).states.contents.offset(i_2 as isize)
                            as *mut QueryState;
                    let mut step_2: *mut QueryStep =
                        &mut *(*(*self_0).query).steps.contents.offset((*state_0).step_index
                                                                           as
                                                                           isize)
                            as *mut QueryStep;
                    (*state_0).set_has_in_progress_alternatives(0 as
                                                                    libc::c_int
                                                                    != 0);
                    copy_count = 0 as libc::c_int as libc::c_uint;
                    // Check that the node matches all of the criteria for the next
        // step of the pattern.
                    if !(((*state_0).start_depth as
                              uint32_t).wrapping_add((*step_2).depth as
                                                         uint32_t) !=
                             (*self_0).depth) {
                        // Determine if this node matches this step of the pattern, and also
        // if this node can have later siblings that match this step of the
        // pattern.
                        let mut node_does_match: bool =
                            (*step_2).symbol as libc::c_int ==
                                symbol as libc::c_int ||
                                (*step_2).symbol as libc::c_int ==
                                    WILDCARD_SYMBOL as libc::c_int ||
                                (*step_2).symbol as libc::c_int ==
                                    NAMED_WILDCARD_SYMBOL as libc::c_int &&
                                    is_named as libc::c_int != 0;
                        let mut later_sibling_can_match: bool =
                            can_have_later_siblings;
                        if (*step_2).is_immediate() as libc::c_int != 0 &&
                               is_named as libc::c_int != 0 ||
                               (*state_0).seeking_immediate_match() as
                                   libc::c_int != 0 {
                            later_sibling_can_match = 0 as libc::c_int != 0
                        }
                        if (*step_2).is_last_child() as libc::c_int != 0 &&
                               can_have_later_siblings as libc::c_int != 0 {
                            node_does_match = 0 as libc::c_int != 0
                        }
                        if (*step_2).field != 0 {
                            if (*step_2).field as libc::c_int ==
                                   field_id as libc::c_int {
                                if !can_have_later_siblings_with_this_field {
                                    later_sibling_can_match =
                                        0 as libc::c_int != 0
                                }
                            } else { node_does_match = 0 as libc::c_int != 0 }
                        }
                        // Remove states immediately if it is ever clear that they cannot match.
                        if !node_does_match {
                            if !later_sibling_can_match {
                                capture_list_pool_release(&mut (*self_0).capture_list_pool,
                                                          (*state_0).capture_list_id);
                                array__erase(&mut (*self_0).states as
                                                 *mut C2RustUnnamed_12 as
                                                 *mut VoidArray,
                                             ::std::mem::size_of::<QueryState>()
                                                 as libc::c_ulong, i_2);
                                i_2 = i_2.wrapping_sub(1)
                            }
                        } else {
                            // Some patterns can match their root node in multiple ways, capturing different
        // children. If this pattern step could match later children within the same
        // parent, then this query state cannot simply be updated in place. It must be
        // split into two states: one that matches this node, and one which skips over
        // this node, to preserve the possibility of matching later siblings.
                            if later_sibling_can_match as libc::c_int != 0 &&
                                   !(*step_2).is_pattern_start() &&
                                   (*step_2).contains_captures() as
                                       libc::c_int != 0 {
                                if !ts_query__cursor_copy_state(self_0,
                                                                state_0).is_null()
                                   {
                                    copy_count = copy_count.wrapping_add(1)
                                }
                            }
                            // If the current node is captured in this pattern, add it to the capture list.
        // For the first capture in a pattern, lazily acquire a capture list.
                            if (*step_2).capture_ids[0 as libc::c_int as
                                                         usize] as libc::c_int
                                   != NONE as libc::c_int {
                                if (*state_0).capture_list_id as libc::c_int
                                       == NONE as libc::c_int {
                                    (*state_0).capture_list_id =
                                        capture_list_pool_acquire(&mut (*self_0).capture_list_pool);
                                    // If there are no capture lists left in the pool, then terminate whichever
            // state has captured the earliest node in the document, and steal its
            // capture list.
                                    if (*state_0).capture_list_id as
                                           libc::c_int == NONE as libc::c_int
                                       {
                                        let mut state_index: uint32_t = 0;
                                        let mut byte_offset: uint32_t = 0;
                                        let mut pattern_index: uint32_t = 0;
                                        if ts_query_cursor__first_in_progress_capture(self_0,
                                                                                      &mut state_index,
                                                                                      &mut byte_offset,
                                                                                      &mut pattern_index)
                                           {
                                            (*state_0).capture_list_id =
                                                (*(*self_0).states.contents.offset(state_index
                                                                                       as
                                                                                       isize)).capture_list_id;
                                            array__erase(&mut (*self_0).states
                                                             as
                                                             *mut C2RustUnnamed_12
                                                             as
                                                             *mut VoidArray,
                                                         ::std::mem::size_of::<QueryState>()
                                                             as libc::c_ulong,
                                                         state_index);
                                            if state_index < i_2 {
                                                i_2 = i_2.wrapping_sub(1);
                                                state_0 = state_0.offset(-1)
                                            }
                                            current_block_103 =
                                                8304106758420804164;
                                        } else {
                                            array__erase(&mut (*self_0).states
                                                             as
                                                             *mut C2RustUnnamed_12
                                                             as
                                                             *mut VoidArray,
                                                         ::std::mem::size_of::<QueryState>()
                                                             as libc::c_ulong,
                                                         i_2);
                                            i_2 = i_2.wrapping_sub(1);
                                            current_block_103 =
                                                317151059986244064;
                                        }
                                    } else {
                                        current_block_103 =
                                            8304106758420804164;
                                    }
                                } else {
                                    current_block_103 = 8304106758420804164;
                                }
                                match current_block_103 {
                                    317151059986244064 => { }
                                    _ => {
                                        let mut capture_list:
                                                *mut CaptureList =
                                            capture_list_pool_get_mut(&mut (*self_0).capture_list_pool,
                                                                      (*state_0).capture_list_id);
                                        let mut j: libc::c_uint =
                                            0 as libc::c_int as libc::c_uint;
                                        while j <
                                                  3 as libc::c_int as
                                                      libc::c_uint {
                                            let mut capture_id: uint16_t =
                                                (*step_2).capture_ids[j as
                                                                          usize];
                                            if (*step_2).capture_ids[j as
                                                                         usize]
                                                   as libc::c_int ==
                                                   NONE as libc::c_int {
                                                break ;
                                            }
                                            array__grow(capture_list as
                                                            *mut VoidArray,
                                                        1 as libc::c_int as
                                                            size_t,
                                                        ::std::mem::size_of::<TSQueryCapture>()
                                                            as libc::c_ulong);
                                            let fresh27 =
                                                (*capture_list).size;
                                            (*capture_list).size =
                                                (*capture_list).size.wrapping_add(1);
                                            *(*capture_list).contents.offset(fresh27
                                                                                 as
                                                                                 isize)
                                                =
                                                {
                                                    let mut init =
                                                        TSQueryCapture{node:
                                                                           node,
                                                                       index:
                                                                           capture_id
                                                                               as
                                                                               uint32_t,};
                                                    init
                                                };
                                            j = j.wrapping_add(1)
                                        }
                                        current_block_103 =
                                            1069630499025798221;
                                    }
                                }
                            } else {
                                current_block_103 = 1069630499025798221;
                            }
                            match current_block_103 {
                                317151059986244064 => { }
                                _ => {
                                    // Advance this state to the next step of its pattern.
                                    (*state_0).step_index =
                                        (*state_0).step_index.wrapping_add(1);
                                    (*state_0).set_seeking_immediate_match(0
                                                                               as
                                                                               libc::c_int
                                                                               !=
                                                                               0);
                                    // If this state's next step has an 'alternative' step (the step is either optional,
        // or is the end of a repetition), then copy the state in order to pursue both
        // alternatives. The alternative step itself may have an alternative, so this is
        // an interative process.
                                    let mut end_index: libc::c_uint =
                                        i_2.wrapping_add(1 as libc::c_int as
                                                             libc::c_uint);
                                    let mut j_0: libc::c_uint = i_2;
                                    while j_0 < end_index {
                                        let mut state_1: *mut QueryState =
                                            &mut *(*self_0).states.contents.offset(j_0
                                                                                       as
                                                                                       isize)
                                                as *mut QueryState;
                                        let mut next_step: *mut QueryStep =
                                            &mut *(*(*self_0).query).steps.contents.offset((*state_1).step_index
                                                                                               as
                                                                                               isize)
                                                as *mut QueryStep;
                                        if (*next_step).alternative_index as
                                               libc::c_int !=
                                               NONE as libc::c_int {
                                            if (*next_step).is_dead_end() {
                                                (*state_1).step_index =
                                                    (*next_step).alternative_index;
                                                j_0 = j_0.wrapping_sub(1)
                                            } else {
                                                let mut copy:
                                                        *mut QueryState =
                                                    ts_query__cursor_copy_state(self_0,
                                                                                state_1);
                                                if (*next_step).is_pass_through()
                                                   {
                                                    (*state_1).step_index =
                                                        (*state_1).step_index.wrapping_add(1);
                                                    j_0 = j_0.wrapping_sub(1)
                                                }
                                                if !copy.is_null() {
                                                    copy_count =
                                                        copy_count.wrapping_add(1);
                                                    end_index =
                                                        end_index.wrapping_add(1);
                                                    (*copy).step_index =
                                                        (*next_step).alternative_index;
                                                    if (*next_step).alternative_is_immediate()
                                                       {
                                                        (*copy).set_seeking_immediate_match(1
                                                                                                as
                                                                                                libc::c_int
                                                                                                !=
                                                                                                0)
                                                    }
                                                }
                                            }
                                        }
                                        j_0 = j_0.wrapping_add(1)
                                    }
                                }
                            }
                        }
                    }
                    i_2 =
                        i_2.wrapping_add((1 as libc::c_int as
                                              libc::c_uint).wrapping_add(copy_count))
                }
                let mut i_3: libc::c_uint = 0 as libc::c_int as libc::c_uint;
                while i_3 < (*self_0).states.size {
                    let mut state_2: *mut QueryState =
                        &mut *(*self_0).states.contents.offset(i_3 as isize)
                            as *mut QueryState;
                    let mut did_remove: bool = 0 as libc::c_int != 0;
                    let mut current_block_115: u64;
                    // Enfore the longest-match criteria. When a query pattern contains optional or
        // repeated nodes, this is necesssary to avoid multiple redundant states, where
        // one state has a strict subset of another state's captures.
                    let mut j_1: libc::c_uint =
                        i_3.wrapping_add(1 as libc::c_int as libc::c_uint);
                    while j_1 < (*self_0).states.size {
                        let mut other_state: *mut QueryState =
                            &mut *(*self_0).states.contents.offset(j_1 as
                                                                       isize)
                                as *mut QueryState;
                        if (*state_2).pattern_index as libc::c_int ==
                               (*other_state).pattern_index as libc::c_int &&
                               (*state_2).start_depth as libc::c_int ==
                                   (*other_state).start_depth as libc::c_int {
                            let mut left_contains_right: bool = false;
                            let mut right_contains_left: bool = false;
                            ts_query_cursor__compare_captures(self_0, state_2,
                                                              other_state,
                                                              &mut left_contains_right,
                                                              &mut right_contains_left);
                            if left_contains_right {
                                if (*state_2).step_index as libc::c_int ==
                                       (*other_state).step_index as
                                           libc::c_int {
                                    capture_list_pool_release(&mut (*self_0).capture_list_pool,
                                                              (*other_state).capture_list_id);
                                    array__erase(&mut (*self_0).states as
                                                     *mut C2RustUnnamed_12 as
                                                     *mut VoidArray,
                                                 ::std::mem::size_of::<QueryState>()
                                                     as libc::c_ulong, j_1);
                                    j_1 = j_1.wrapping_sub(1);
                                    current_block_115 = 10783567741412653655;
                                } else {
                                    (*other_state).set_has_in_progress_alternatives(1
                                                                                        as
                                                                                        libc::c_int
                                                                                        !=
                                                                                        0);
                                    current_block_115 = 11359721434352816539;
                                }
                            } else {
                                current_block_115 = 11359721434352816539;
                            }
                            match current_block_115 {
                                10783567741412653655 => { }
                                _ => {
                                    if right_contains_left {
                                        if (*state_2).step_index as
                                               libc::c_int ==
                                               (*other_state).step_index as
                                                   libc::c_int {
                                            capture_list_pool_release(&mut (*self_0).capture_list_pool,
                                                                      (*state_2).capture_list_id);
                                            array__erase(&mut (*self_0).states
                                                             as
                                                             *mut C2RustUnnamed_12
                                                             as
                                                             *mut VoidArray,
                                                         ::std::mem::size_of::<QueryState>()
                                                             as libc::c_ulong,
                                                         i_3);
                                            did_remove =
                                                1 as libc::c_int != 0;
                                            break ;
                                        } else {
                                            (*state_2).set_has_in_progress_alternatives(1
                                                                                            as
                                                                                            libc::c_int
                                                                                            !=
                                                                                            0)
                                        }
                                    }
                                }
                            }
                        }
                        j_1 = j_1.wrapping_add(1)
                    }
                    // If there the state is at the end of its pattern, remove it from the list
        // of in-progress states and add it to the list of finished states.
                    if !did_remove {
                        let mut next_step_0: *mut QueryStep =
                            &mut *(*(*self_0).query).steps.contents.offset((*state_2).step_index
                                                                               as
                                                                               isize)
                                as *mut QueryStep;
                        if (*next_step_0).depth as libc::c_int ==
                               PATTERN_DONE_MARKER as libc::c_int {
                            if !(*state_2).has_in_progress_alternatives() {
                                let fresh28 = (*self_0).next_state_id;
                                (*self_0).next_state_id =
                                    (*self_0).next_state_id.wrapping_add(1);
                                (*state_2).id = fresh28;
                                array__grow(&mut (*self_0).finished_states as
                                                *mut C2RustUnnamed_11 as
                                                *mut VoidArray,
                                            1 as libc::c_int as size_t,
                                            ::std::mem::size_of::<QueryState>()
                                                as libc::c_ulong);
                                let fresh29 = (*self_0).finished_states.size;
                                (*self_0).finished_states.size =
                                    (*self_0).finished_states.size.wrapping_add(1);
                                *(*self_0).finished_states.contents.offset(fresh29
                                                                               as
                                                                               isize)
                                    = *state_2;
                                array__erase(&mut (*self_0).states as
                                                 *mut C2RustUnnamed_12 as
                                                 *mut VoidArray,
                                             ::std::mem::size_of::<QueryState>()
                                                 as libc::c_ulong,
                                             state_2.wrapping_offset_from((*self_0).states.contents)
                                                 as libc::c_long as uint32_t);
                                i_3 = i_3.wrapping_sub(1)
                            }
                        }
                    }
                    i_3 = i_3.wrapping_add(1)
                }
                // Continue descending if possible.
                if ts_tree_cursor_goto_first_child(&mut (*self_0).cursor) {
                    (*self_0).depth = (*self_0).depth.wrapping_add(1)
                } else { (*self_0).ascending = 1 as libc::c_int != 0 }
            }
        }
        if !((*self_0).finished_states.size ==
                 0 as libc::c_int as libc::c_uint) {
            break ;
        }
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn ts_query_cursor_next_match(mut self_0:
                                                        *mut TSQueryCursor,
                                                    mut match_0:
                                                        *mut TSQueryMatch)
 -> bool {
    if (*self_0).finished_states.size == 0 as libc::c_int as libc::c_uint {
        if !ts_query_cursor__advance(self_0) { return 0 as libc::c_int != 0 }
    }
    let mut state: *mut QueryState =
        &mut *(*self_0).finished_states.contents.offset(0 as libc::c_int as
                                                            isize) as
            *mut QueryState;
    (*match_0).id = (*state).id;
    (*match_0).pattern_index = (*state).pattern_index;
    let mut captures: *const CaptureList =
        capture_list_pool_get(&mut (*self_0).capture_list_pool,
                              (*state).capture_list_id);
    (*match_0).captures = (*captures).contents;
    (*match_0).capture_count = (*captures).size as uint16_t;
    capture_list_pool_release(&mut (*self_0).capture_list_pool,
                              (*state).capture_list_id);
    array__erase(&mut (*self_0).finished_states as *mut C2RustUnnamed_11 as
                     *mut VoidArray,
                 ::std::mem::size_of::<QueryState>() as libc::c_ulong,
                 0 as libc::c_int as uint32_t);
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn ts_query_cursor_remove_match(mut self_0:
                                                          *mut TSQueryCursor,
                                                      mut match_id:
                                                          uint32_t) {
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    while i < (*self_0).finished_states.size {
        let mut state: *const QueryState =
            &mut *(*self_0).finished_states.contents.offset(i as isize) as
                *mut QueryState;
        if (*state).id == match_id {
            capture_list_pool_release(&mut (*self_0).capture_list_pool,
                                      (*state).capture_list_id);
            array__erase(&mut (*self_0).finished_states as
                             *mut C2RustUnnamed_11 as *mut VoidArray,
                         ::std::mem::size_of::<QueryState>() as libc::c_ulong,
                         i);
            return
        }
        i = i.wrapping_add(1)
    };
}
/* *******************/
/* Section - Parser */
/* *******************/
/* *
 * Create a new parser.
 */
/* *
 * Delete the parser, freeing all of the memory that it used.
 */
/* *
 * Set the language that the parser should use for parsing.
 *
 * Returns a boolean indicating whether or not the language was successfully
 * assigned. True means assignment succeeded. False means there was a version
 * mismatch: the language was generated with an incompatible version of the
 * Tree-sitter CLI. Check the language's version using `ts_language_version`
 * and compare it to this library's `TREE_SITTER_LANGUAGE_VERSION` and
 * `TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION` constants.
 */
/* *
 * Get the parser's current language.
 */
/* *
 * Set the ranges of text that the parser should include when parsing.
 *
 * By default, the parser will always include entire documents. This function
 * allows you to parse only a *portion* of a document but still return a syntax
 * tree whose ranges match up with the document as a whole. You can also pass
 * multiple disjoint ranges.
 *
 * The second and third parameters specify the location and length of an array
 * of ranges. The parser does *not* take ownership of these ranges; it copies
 * the data, so it doesn't matter how these ranges are allocated.
 *
 * If `length` is zero, then the entire document will be parsed. Otherwise,
 * the given ranges must be ordered from earliest to latest in the document,
 * and they must not overlap. That is, the following must hold for all
 * `i` < `length - 1`:
 *
 *     ranges[i].end_byte <= ranges[i + 1].start_byte
 *
 * If this requirement is not satisfied, the operation will fail, the ranges
 * will not be assigned, and this function will return `false`. On success,
 * this function returns `true`
 */
/* *
 * Get the ranges of text that the parser will include when parsing.
 *
 * The returned pointer is owned by the parser. The caller should not free it
 * or write to it. The length of the array will be written to the given
 * `length` pointer.
 */
/* *
 * Use the parser to parse some source code and create a syntax tree.
 *
 * If you are parsing this document for the first time, pass `NULL` for the
 * `old_tree` parameter. Otherwise, if you have already parsed an earlier
 * version of this document and the document has since been edited, pass the
 * previous syntax tree so that the unchanged parts of it can be reused.
 * This will save time and memory. For this to work correctly, you must have
 * already edited the old syntax tree using the `ts_tree_edit` function in a
 * way that exactly matches the source code changes.
 *
 * The `TSInput` parameter lets you specify how to read the text. It has the
 * following three fields:
 * 1. `read`: A function to retrieve a chunk of text at a given byte offset
 *    and (row, column) position. The function should return a pointer to the
 *    text and write its length to the the `bytes_read` pointer. The parser
 *    does not take ownership of this buffer; it just borrows it until it has
 *    finished reading it. The function should write a zero value to the
 *    `bytes_read` pointer to indicate the end of the document.
 * 2. `payload`: An arbitrary pointer that will be passed to each invocation
 *    of the `read` function.
 * 3. `encoding`: An indication of how the text is encoded. Either
 *    `TSInputEncodingUTF8` or `TSInputEncodingUTF16`.
 *
 * This function returns a syntax tree on success, and `NULL` on failure. There
 * are three possible reasons for failure:
 * 1. The parser does not have a language assigned. Check for this using the
      `ts_parser_language` function.
 * 2. Parsing was cancelled due to a timeout that was set by an earlier call to
 *    the `ts_parser_set_timeout_micros` function. You can resume parsing from
 *    where the parser left out by calling `ts_parser_parse` again with the
 *    same arguments. Or you can start parsing from scratch by first calling
 *    `ts_parser_reset`.
 * 3. Parsing was cancelled using a cancellation flag that was set by an
 *    earlier call to `ts_parser_set_cancellation_flag`. You can resume parsing
 *    from where the parser left out by calling `ts_parser_parse` again with
 *    the same arguments.
 */
/* *
 * Use the parser to parse some source code stored in one contiguous buffer.
 * The first two parameters are the same as in the `ts_parser_parse` function
 * above. The second two parameters indicate the location of the buffer and its
 * length in bytes.
 */
/* *
 * Use the parser to parse some source code stored in one contiguous buffer with
 * a given encoding. The first four parameters work the same as in the
 * `ts_parser_parse_string` method above. The final parameter indicates whether
 * the text is encoded as UTF8 or UTF16.
 */
/* *
 * Instruct the parser to start the next parse from the beginning.
 *
 * If the parser previously failed because of a timeout or a cancellation, then
 * by default, it will resume where it left off on the next call to
 * `ts_parser_parse` or other parsing functions. If you don't want to resume,
 * and instead intend to use this parser to parse some other document, you must
 * call `ts_parser_reset` first.
 */
/* *
 * Set the maximum duration in microseconds that parsing should be allowed to
 * take before halting.
 *
 * If parsing takes longer than this, it will halt early, returning NULL.
 * See `ts_parser_parse` for more information.
 */
/* *
 * Get the duration in microseconds that parsing is allowed to take.
 */
/* *
 * Set the parser's current cancellation flag pointer.
 *
 * If a non-null pointer is assigned, then the parser will periodically read
 * from this pointer during parsing. If it reads a non-zero value, it will
 * halt early, returning NULL. See `ts_parser_parse` for more information.
 */
/* *
 * Get the parser's current cancellation flag pointer.
 */
/* *
 * Set the logger that a parser should use during parsing.
 *
 * The parser does not take ownership over the logger payload. If a logger was
 * previously assigned, the caller is responsible for releasing any memory
 * owned by the previous logger.
 */
/* *
 * Get the parser's current logger.
 */
/* *
 * Set the file descriptor to which the parser should write debugging graphs
 * during parsing. The graphs are formatted in the DOT language. You may want
 * to pipe these graphs directly to a `dot(1)` process in order to generate
 * SVG output. You can turn off this logging by passing a negative number.
 */
/* *****************/
/* Section - Tree */
/* *****************/
/* *
 * Create a shallow copy of the syntax tree. This is very fast.
 *
 * You need to copy a syntax tree in order to use it on more than one thread at
 * a time, as syntax trees are not thread safe.
 */
/* *
 * Delete the syntax tree, freeing all of the memory that it used.
 */
/* *
 * Get the root node of the syntax tree.
 */
/* *
 * Get the language that was used to parse the syntax tree.
 */
/* *
 * Edit the syntax tree to keep it in sync with source code that has been
 * edited.
 *
 * You must describe the edit both in terms of byte offsets and in terms of
 * (row, column) coordinates.
 */
/* *
 * Compare an old edited syntax tree to a new syntax tree representing the same
 * document, returning an array of ranges whose syntactic structure has changed.
 *
 * For this to work correctly, the old syntax tree must have been edited such
 * that its ranges match up to the new tree. Generally, you'll want to call
 * this function right after calling one of the `ts_parser_parse` functions.
 * You need to pass the old tree that was passed to parse, as well as the new
 * tree that was returned from that function.
 *
 * The returned array is allocated using `malloc` and the caller is responsible
 * for freeing it using `free`. The length of the array will be written to the
 * given `length` pointer.
 */
/* *
 * Write a DOT graph describing the syntax tree to the given file.
 */
/* *****************/
/* Section - Node */
/* *****************/
/* *
 * Get the node's type as a null-terminated string.
 */
/* *
 * Get the node's type as a numerical id.
 */
/* *
 * Get the node's start byte.
 */
/* *
 * Get the node's start position in terms of rows and columns.
 */
/* *
 * Get the node's end byte.
 */
/* *
 * Get the node's end position in terms of rows and columns.
 */
/* *
 * Get an S-expression representing the node as a string.
 *
 * This string is allocated with `malloc` and the caller is responsible for
 * freeing it using `free`.
 */
/* *
 * Check if the node is null. Functions like `ts_node_child` and
 * `ts_node_next_sibling` will return a null node to indicate that no such node
 * was found.
 */
/* *
 * Check if the node is *named*. Named nodes correspond to named rules in the
 * grammar, whereas *anonymous* nodes correspond to string literals in the
 * grammar.
 */
/* *
 * Check if the node is *missing*. Missing nodes are inserted by the parser in
 * order to recover from certain kinds of syntax errors.
 */
/* *
 * Check if the node is *extra*. Extra nodes represent things like comments,
 * which are not required the grammar, but can appear anywhere.
 */
/* *
 * Check if a syntax node has been edited.
 */
/* *
 * Check if the node is a syntax error or contains any syntax errors.
 */
/* *
 * Get the node's immediate parent.
 */
/* *
 * Get the node's child at the given index, where zero represents the first
 * child.
 */
/* *
 * Get the node's number of children.
 */
/* *
 * Get the node's *named* child at the given index.
 *
 * See also `ts_node_is_named`.
 */
/* *
 * Get the node's number of *named* children.
 *
 * See also `ts_node_is_named`.
 */
/* *
 * Get the node's child with the given field name.
 */
/* *
 * Get the node's child with the given numerical field id.
 *
 * You can convert a field name to an id using the
 * `ts_language_field_id_for_name` function.
 */
/* *
 * Get the node's next / previous sibling.
 */
/* *
 * Get the node's next / previous *named* sibling.
 */
/* *
 * Get the node's first child that extends beyond the given byte offset.
 */
/* *
 * Get the node's first named child that extends beyond the given byte offset.
 */
/* *
 * Get the smallest node within this node that spans the given range of bytes
 * or (row, column) positions.
 */
/* *
 * Get the smallest named node within this node that spans the given range of
 * bytes or (row, column) positions.
 */
/* *
 * Edit the node to keep it in-sync with source code that has been edited.
 *
 * This function is only rarely needed. When you edit a syntax tree with the
 * `ts_tree_edit` function, all of the nodes that you retrieve from the tree
 * afterward will already reflect the edit. You only need to use `ts_node_edit`
 * when you have a `TSNode` instance that you want to keep and continue to use
 * after an edit.
 */
/* *
 * Check if two nodes are identical.
 */
/* ***********************/
/* Section - TreeCursor */
/* ***********************/
/* *
 * Create a new tree cursor starting from the given node.
 *
 * A tree cursor allows you to walk a syntax tree more efficiently than is
 * possible using the `TSNode` functions. It is a mutable object that is always
 * on a certain syntax node, and can be moved imperatively to different nodes.
 */
/* *
 * Delete a tree cursor, freeing all of the memory that it used.
 */
/* *
 * Re-initialize a tree cursor to start at a different node.
 */
/* *
 * Get the tree cursor's current node.
 */
/* *
 * Get the field name of the tree cursor's current node.
 *
 * This returns `NULL` if the current node doesn't have a field.
 * See also `ts_node_child_by_field_name`.
 */
/* *
 * Get the field name of the tree cursor's current node.
 *
 * This returns zero if the current node doesn't have a field.
 * See also `ts_node_child_by_field_id`, `ts_language_field_id_for_name`.
 */
/* *
 * Move the cursor to the parent of its current node.
 *
 * This returns `true` if the cursor successfully moved, and returns `false`
 * if there was no parent node (the cursor was already on the root node).
 */
/* *
 * Move the cursor to the next sibling of its current node.
 *
 * This returns `true` if the cursor successfully moved, and returns `false`
 * if there was no next sibling node.
 */
/* *
 * Move the cursor to the first child of its current node.
 *
 * This returns `true` if the cursor successfully moved, and returns `false`
 * if there were no children.
 */
/* *
 * Move the cursor to the first child of its current node that extends beyond
 * the given byte offset.
 *
 * This returns the index of the child node if one was found, and returns -1
 * if no such child was found.
 */
/* ******************/
/* Section - Query */
/* ******************/
/* *
 * Create a new query from a string containing one or more S-expression
 * patterns. The query is associated with a particular language, and can
 * only be run on syntax nodes parsed with that language.
 *
 * If all of the given patterns are valid, this returns a `TSQuery`.
 * If a pattern is invalid, this returns `NULL`, and provides two pieces
 * of information about the problem:
 * 1. The byte offset of the error is written to the `error_offset` parameter.
 * 2. The type of error is written to the `error_type` parameter.
 */
/* *
 * Delete a query, freeing all of the memory that it used.
 */
/* *
 * Get the number of patterns, captures, or string literals in the query.
 */
/* *
 * Get the byte offset where the given pattern starts in the query's source.
 *
 * This can be useful when combining queries by concatenating their source
 * code strings.
 */
/* *
 * Get all of the predicates for the given pattern in the query.
 *
 * The predicates are represented as a single array of steps. There are three
 * types of steps in this array, which correspond to the three legal values for
 * the `type` field:
 * - `TSQueryPredicateStepTypeCapture` - Steps with this type represent names
 *    of captures. Their `value_id` can be used with the
 *   `ts_query_capture_name_for_id` function to obtain the name of the capture.
 * - `TSQueryPredicateStepTypeString` - Steps with this type represent literal
 *    strings. Their `value_id` can be used with the
 *    `ts_query_string_value_for_id` function to obtain their string value.
 * - `TSQueryPredicateStepTypeDone` - Steps with this type are *sentinels*
 *    that represent the end of an individual predicate. If a pattern has two
 *    predicates, then there will be two steps with this `type` in the array.
 */
/* *
 * Get the name and length of one of the query's captures, or one of the
 * query's string literals. Each capture and string is associated with a
 * numeric id based on the order that it appeared in the query's source.
 */
/* *
 * Disable a certain capture within a query.
 *
 * This prevents the capture from being returned in matches, and also avoids
 * any resource usage associated with recording the capture. Currently, there
 * is no way to undo this.
 */
/* *
 * Disable a certain pattern within a query.
 *
 * This prevents the pattern from matching and removes most of the overhead
 * associated with the pattern. Currently, there is no way to undo this.
 */
/* *
 * Create a new cursor for executing a given query.
 *
 * The cursor stores the state that is needed to iteratively search
 * for matches. To use the query cursor, first call `ts_query_cursor_exec`
 * to start running a given query on a given syntax node. Then, there are
 * two options for consuming the results of the query:
 * 1. Repeatedly call `ts_query_cursor_next_match` to iterate over all of the
 *    the *matches* in the order that they were found. Each match contains the
 *    index of the pattern that matched, and an array of captures. Because
 *    multiple patterns can match the same set of nodes, one match may contain
 *    captures that appear *before* some of the captures from a previous match.
 * 2. Repeatedly call `ts_query_cursor_next_capture` to iterate over all of the
 *    individual *captures* in the order that they appear. This is useful if
 *    don't care about which pattern matched, and just want a single ordered
 *    sequence of captures.
 *
 * If you don't care about consuming all of the results, you can stop calling
 * `ts_query_cursor_next_match` or `ts_query_cursor_next_capture` at any point.
 *  You can then start executing another query on another node by calling
 *  `ts_query_cursor_exec` again.
 */
/* *
 * Delete a query cursor, freeing all of the memory that it used.
 */
/* *
 * Start running a given query on a given node.
 */
/* *
 * Set the range of bytes or (row, column) positions in which the query
 * will be executed.
 */
/* *
 * Advance to the next match of the currently running query.
 *
 * If there is a match, write it to `*match` and return `true`.
 * Otherwise, return `false`.
 */
/* *
 * Advance to the next capture of the currently running query.
 *
 * If there is a capture, write its match to `*match` and its index within
 * the matche's capture list to `*capture_index`. Otherwise, return `false`.
 */
#[no_mangle]
pub unsafe extern "C" fn ts_query_cursor_next_capture(mut self_0:
                                                          *mut TSQueryCursor,
                                                      mut match_0:
                                                          *mut TSQueryMatch,
                                                      mut capture_index:
                                                          *mut uint32_t)
 -> bool {
    loop  {
        // The goal here is to return captures in order, even though they may not
    // be discovered in order, because patterns can overlap. If there are any
    // finished patterns, then try to find one that contains a capture that
    // is *definitely* before any capture in an *unfinished* pattern.
        if (*self_0).finished_states.size > 0 as libc::c_int as libc::c_uint {
            // First, identify the position of the earliest capture in an unfinished
      // match. For a finished capture to be returned, it must be *before*
      // this position.
            let mut first_unfinished_capture_byte: uint32_t = 0;
            let mut first_unfinished_pattern_index: uint32_t = 0;
            let mut first_unfinished_state_index: uint32_t = 0;
            ts_query_cursor__first_in_progress_capture(self_0,
                                                       &mut first_unfinished_state_index,
                                                       &mut first_unfinished_capture_byte,
                                                       &mut first_unfinished_pattern_index);
            // Find the earliest capture in a finished match.
            let mut first_finished_state_index: libc::c_int =
                -(1 as libc::c_int);
            let mut first_finished_capture_byte: uint32_t =
                first_unfinished_capture_byte;
            let mut first_finished_pattern_index: uint32_t =
                first_unfinished_pattern_index;
            let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
            while i < (*self_0).finished_states.size {
                let mut state: *const QueryState =
                    &mut *(*self_0).finished_states.contents.offset(i as
                                                                        isize)
                        as *mut QueryState;
                let mut captures: *const CaptureList =
                    capture_list_pool_get(&mut (*self_0).capture_list_pool,
                                          (*state).capture_list_id);
                if (*captures).size >
                       (*state).consumed_capture_count() as libc::c_uint {
                    let mut capture_byte: uint32_t =
                        ts_node_start_byte((*(*captures).contents.offset((*state).consumed_capture_count()
                                                                             as
                                                                             isize)).node);
                    if capture_byte < first_finished_capture_byte ||
                           capture_byte == first_finished_capture_byte &&
                               ((*state).pattern_index as libc::c_uint) <
                                   first_finished_pattern_index {
                        first_finished_state_index = i as libc::c_int;
                        first_finished_capture_byte = capture_byte;
                        first_finished_pattern_index =
                            (*state).pattern_index as uint32_t
                    }
                } else {
                    capture_list_pool_release(&mut (*self_0).capture_list_pool,
                                              (*state).capture_list_id);
                    array__erase(&mut (*self_0).finished_states as
                                     *mut C2RustUnnamed_11 as *mut VoidArray,
                                 ::std::mem::size_of::<QueryState>() as
                                     libc::c_ulong, i);
                    i = i.wrapping_sub(1)
                }
                i = i.wrapping_add(1)
            }
            // If there is finished capture that is clearly before any unfinished
      // capture, then return its match, and its capture index. Internally
      // record the fact that the capture has been 'consumed'.
            if first_finished_state_index != -(1 as libc::c_int) {
                let mut state_0: *mut QueryState =
                    &mut *(*self_0).finished_states.contents.offset(first_finished_state_index
                                                                        as
                                                                        isize)
                        as *mut QueryState;
                (*match_0).id = (*state_0).id;
                (*match_0).pattern_index = (*state_0).pattern_index;
                let mut captures_0: *const CaptureList =
                    capture_list_pool_get(&mut (*self_0).capture_list_pool,
                                          (*state_0).capture_list_id);
                (*match_0).captures = (*captures_0).contents;
                (*match_0).capture_count = (*captures_0).size as uint16_t;
                *capture_index =
                    (*state_0).consumed_capture_count() as uint32_t;
                (*state_0).set_consumed_capture_count((*state_0).consumed_capture_count()
                                                          + 1);
                return 1 as libc::c_int != 0
            }
            if capture_list_pool_is_empty(&mut (*self_0).capture_list_pool) {
                capture_list_pool_release(&mut (*self_0).capture_list_pool,
                                          (*(*self_0).states.contents.offset(first_unfinished_state_index
                                                                                 as
                                                                                 isize)).capture_list_id);
                array__erase(&mut (*self_0).states as *mut C2RustUnnamed_12 as
                                 *mut VoidArray,
                             ::std::mem::size_of::<QueryState>() as
                                 libc::c_ulong, first_unfinished_state_index);
            }
        }
        // If there are no finished matches that are ready to be returned, then
    // continue finding more matches.
        if !ts_query_cursor__advance(self_0) { return 0 as libc::c_int != 0 }
    };
}
