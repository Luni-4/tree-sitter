#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case,
         non_upper_case_globals, unused_assignments, unused_mut)]
#![register_tool(c2rust)]
#![feature(const_raw_ptr_to_usize_cast, core_intrinsics, extern_types,
           label_break_value, ptr_wrapping_offset_from, register_tool)]
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    #[no_mangle]
    fn __assert_fail(__assertion: *const libc::c_char,
                     __file: *const libc::c_char, __line: libc::c_uint,
                     __function: *const libc::c_char) -> !;
    #[no_mangle]
    fn __ctype_b_loc() -> *mut *const libc::c_ushort;
    #[no_mangle]
    fn memcpy(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_ulong)
     -> *mut libc::c_void;
    #[no_mangle]
    fn memcmp(_: *const libc::c_void, _: *const libc::c_void,
              _: libc::c_ulong) -> libc::c_int;
    #[no_mangle]
    static mut stderr: *mut FILE;
    #[no_mangle]
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    #[no_mangle]
    fn snprintf(_: *mut libc::c_char, _: libc::c_ulong,
                _: *const libc::c_char, _: ...) -> libc::c_int;
    #[no_mangle]
    fn fputc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
    #[no_mangle]
    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
    #[no_mangle]
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    #[no_mangle]
    fn free(__ptr: *mut libc::c_void);
    #[no_mangle]
    fn exit(_: libc::c_int) -> !;
    /* *
 * Get a node type string for the given numerical id.
 */
    #[no_mangle]
    fn ts_language_symbol_name(_: *const TSLanguage, _: TSSymbol)
     -> *const libc::c_char;
    #[no_mangle]
    fn ts_language_symbol_metadata(_: *const TSLanguage, _: TSSymbol)
     -> TSSymbolMetadata;
}
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type C2RustUnnamed = libc::c_uint;
pub const _ISalnum: C2RustUnnamed = 8;
pub const _ISpunct: C2RustUnnamed = 4;
pub const _IScntrl: C2RustUnnamed = 2;
pub const _ISblank: C2RustUnnamed = 1;
pub const _ISgraph: C2RustUnnamed = 32768;
pub const _ISprint: C2RustUnnamed = 16384;
pub const _ISspace: C2RustUnnamed = 8192;
pub const _ISxdigit: C2RustUnnamed = 4096;
pub const _ISdigit: C2RustUnnamed = 2048;
pub const _ISalpha: C2RustUnnamed = 1024;
pub const _ISlower: C2RustUnnamed = 512;
pub const _ISupper: C2RustUnnamed = 256;
pub type size_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type int16_t = __int16_t;
pub type int32_t = __int32_t;
pub type uint8_t = __uint8_t;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
/* ***************************/
/* Section - ABI Versioning */
/* ***************************/
/* *
 * The latest ABI version that is supported by the current version of the
 * library. When Languages are generated by the Tree-sitter CLI, they are
 * assigned an ABI version number that corresponds to the current CLI version.
 * The Tree-sitter library is generally backwards-compatible with languages
 * generated using older CLI versions, but is not forwards-compatible.
 */
/* *
 * The earliest ABI version that is supported by the current version of the
 * library.
 */
/* ******************/
/* Section - Types */
/* ******************/
pub type TSSymbol = uint16_t;
pub type TSFieldId = uint16_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSLanguage {
    pub version: uint32_t,
    pub symbol_count: uint32_t,
    pub alias_count: uint32_t,
    pub token_count: uint32_t,
    pub external_token_count: uint32_t,
    pub symbol_names: *mut *const libc::c_char,
    pub symbol_metadata: *const TSSymbolMetadata,
    pub parse_table: *const uint16_t,
    pub parse_actions: *const TSParseActionEntry,
    pub lex_modes: *const TSLexMode,
    pub alias_sequences: *const TSSymbol,
    pub max_alias_sequence_length: uint16_t,
    pub lex_fn: Option<unsafe extern "C" fn(_: *mut TSLexer, _: TSStateId)
                           -> bool>,
    pub keyword_lex_fn: Option<unsafe extern "C" fn(_: *mut TSLexer,
                                                    _: TSStateId) -> bool>,
    pub keyword_capture_token: TSSymbol,
    pub external_scanner: C2RustUnnamed_0,
    pub field_count: uint32_t,
    pub field_map_slices: *const TSFieldMapSlice,
    pub field_map_entries: *const TSFieldMapEntry,
    pub field_names: *mut *const libc::c_char,
    pub large_state_count: uint32_t,
    pub small_parse_table: *const uint16_t,
    pub small_parse_table_map: *const uint32_t,
    pub public_symbol_map: *const TSSymbol,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSFieldMapEntry {
    pub field_id: TSFieldId,
    pub child_index: uint8_t,
    pub inherited: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSFieldMapSlice {
    pub index: uint16_t,
    pub length: uint16_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_0 {
    pub states: *const bool,
    pub symbol_map: *const TSSymbol,
    pub create: Option<unsafe extern "C" fn() -> *mut libc::c_void>,
    pub destroy: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
    pub scan: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                          _: *mut TSLexer, _: *const bool)
                         -> bool>,
    pub serialize: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                               _: *mut libc::c_char)
                              -> libc::c_uint>,
    pub deserialize: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                 _: *const libc::c_char,
                                                 _: libc::c_uint) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSLexer {
    pub lookahead: int32_t,
    pub result_symbol: TSSymbol,
    pub advance: Option<unsafe extern "C" fn(_: *mut TSLexer, _: bool) -> ()>,
    pub mark_end: Option<unsafe extern "C" fn(_: *mut TSLexer) -> ()>,
    pub get_column: Option<unsafe extern "C" fn(_: *mut TSLexer) -> uint32_t>,
    pub is_at_included_range_start: Option<unsafe extern "C" fn(_:
                                                                    *const TSLexer)
                                               -> bool>,
    pub eof: Option<unsafe extern "C" fn(_: *const TSLexer) -> bool>,
}
pub type TSStateId = uint16_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSLexMode {
    pub lex_state: uint16_t,
    pub external_lex_state: uint16_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union TSParseActionEntry {
    pub action: TSParseAction,
    pub entry: C2RustUnnamed_1,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct C2RustUnnamed_1 {
    pub count: uint8_t,
    #[bitfield(name = "reusable", ty = "bool", bits = "0..=0")]
    pub reusable: [u8; 1],
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct TSParseAction {
    pub params: C2RustUnnamed_2,
    #[bitfield(name = "type_0", ty = "TSParseActionType", bits = "0..=3")]
    pub type_0: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 1],
}
pub type TSParseActionType = libc::c_uint;
pub const TSParseActionTypeRecover: TSParseActionType = 3;
pub const TSParseActionTypeAccept: TSParseActionType = 2;
pub const TSParseActionTypeReduce: TSParseActionType = 1;
pub const TSParseActionTypeShift: TSParseActionType = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_2 {
    pub shift: C2RustUnnamed_4,
    pub reduce: C2RustUnnamed_3,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_3 {
    pub symbol: TSSymbol,
    pub dynamic_precedence: int16_t,
    pub child_count: uint8_t,
    pub production_id: uint8_t,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct C2RustUnnamed_4 {
    pub state: TSStateId,
    #[bitfield(name = "extra", ty = "bool", bits = "0..=0")]
    #[bitfield(name = "repetition", ty = "bool", bits = "1..=1")]
    pub extra_repetition: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 1],
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct TSSymbolMetadata {
    #[bitfield(name = "visible", ty = "bool", bits = "0..=0")]
    #[bitfield(name = "named", ty = "bool", bits = "1..=1")]
    pub visible_named: [u8; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSPoint {
    pub row: uint32_t,
    pub column: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TSInputEdit {
    pub start_byte: uint32_t,
    pub old_end_byte: uint32_t,
    pub new_end_byte: uint32_t,
    pub start_point: TSPoint,
    pub old_end_point: TSPoint,
    pub new_end_point: TSPoint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Length {
    pub bytes: uint32_t,
    pub extent: TSPoint,
}
// Private
#[derive(Copy, Clone)]
#[repr(C)]
pub struct VoidArray {
    pub contents: *mut libc::c_void,
    pub size: uint32_t,
    pub capacity: uint32_t,
}
// Non-terminal subtrees (`child_count > 0`)
// External terminal subtrees (`child_count == 0 && has_external_tokens`)
// Error terminal subtrees (`child_count == 0 && symbol == ts_builtin_sym_error`)
#[derive(Copy, Clone)]
#[repr(C)]
pub union Subtree {
    pub data: SubtreeInlineData,
    pub ptr: *const SubtreeHeapData,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct SubtreeHeapData {
    pub ref_count: uint32_t,
    pub padding: Length,
    pub size: Length,
    pub lookahead_bytes: uint32_t,
    pub error_cost: uint32_t,
    pub child_count: uint32_t,
    pub symbol: TSSymbol,
    pub parse_state: TSStateId,
    #[bitfield(name = "visible", ty = "bool", bits = "0..=0")]
    #[bitfield(name = "named", ty = "bool", bits = "1..=1")]
    #[bitfield(name = "extra", ty = "bool", bits = "2..=2")]
    #[bitfield(name = "fragile_left", ty = "bool", bits = "3..=3")]
    #[bitfield(name = "fragile_right", ty = "bool", bits = "4..=4")]
    #[bitfield(name = "has_changes", ty = "bool", bits = "5..=5")]
    #[bitfield(name = "has_external_tokens", ty = "bool", bits = "6..=6")]
    #[bitfield(name = "is_missing", ty = "bool", bits = "7..=7")]
    #[bitfield(name = "is_keyword", ty = "bool", bits = "8..=8")]
    pub visible_named_extra_fragile_left_fragile_right_has_changes_has_external_tokens_is_missing_is_keyword: [u8; 2],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 2],
    pub c2rust_unnamed: C2RustUnnamed_5,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_5 {
    pub c2rust_unnamed: C2RustUnnamed_7,
    pub external_scanner_state: ExternalScannerState,
    pub lookahead_char: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ExternalScannerState {
    pub c2rust_unnamed: C2RustUnnamed_6,
    pub length: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_6 {
    pub long_data: *mut libc::c_char,
    pub short_data: [libc::c_char; 24],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_7 {
    pub children: *mut Subtree,
    pub visible_child_count: uint32_t,
    pub named_child_count: uint32_t,
    pub node_count: uint32_t,
    pub repeat_depth: uint32_t,
    pub dynamic_precedence: int32_t,
    pub production_id: uint16_t,
    pub first_leaf: C2RustUnnamed_8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_8 {
    pub symbol: TSSymbol,
    pub parse_state: TSStateId,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct SubtreeInlineData {
    #[bitfield(name = "is_inline", ty = "bool", bits = "0..=0")]
    #[bitfield(name = "visible", ty = "bool", bits = "1..=1")]
    #[bitfield(name = "named", ty = "bool", bits = "2..=2")]
    #[bitfield(name = "extra", ty = "bool", bits = "3..=3")]
    #[bitfield(name = "has_changes", ty = "bool", bits = "4..=4")]
    #[bitfield(name = "is_missing", ty = "bool", bits = "5..=5")]
    #[bitfield(name = "is_keyword", ty = "bool", bits = "6..=6")]
    pub is_inline_visible_named_extra_has_changes_is_missing_is_keyword: [u8; 1],
    pub symbol: uint8_t,
    pub padding_bytes: uint8_t,
    pub size_bytes: uint8_t,
    pub padding_columns: uint8_t,
    #[bitfield(name = "padding_rows", ty = "uint8_t", bits = "0..=3")]
    #[bitfield(name = "lookahead_bytes", ty = "uint8_t", bits = "4..=7")]
    pub padding_rows_lookahead_bytes: [u8; 1],
    pub parse_state: uint16_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union MutableSubtree {
    pub data: SubtreeInlineData,
    pub ptr: *mut SubtreeHeapData,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SubtreeArray {
    pub contents: *mut Subtree,
    pub size: uint32_t,
    pub capacity: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct MutableSubtreeArray {
    pub contents: *mut MutableSubtree,
    pub size: uint32_t,
    pub capacity: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SubtreePool {
    pub free_trees: MutableSubtreeArray,
    pub tree_stack: MutableSubtreeArray,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct StackEntry {
    pub tree: *mut Subtree,
    pub edit: Edit,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Edit {
    pub start: Length,
    pub old_end: Length,
    pub new_end: Length,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_9 {
    pub contents: *mut StackEntry,
    pub size: uint32_t,
    pub capacity: uint32_t,
}
#[inline]
unsafe extern "C" fn ts_malloc(mut size: size_t) -> *mut libc::c_void {
    let mut result: *mut libc::c_void = malloc(size);
    if size > 0 as libc::c_int as libc::c_ulong && result.is_null() {
        fprintf(stderr,
                b"tree-sitter failed to allocate %lu bytes\x00" as *const u8
                    as *const libc::c_char, size);
        exit(1 as libc::c_int);
    }
    return result;
}
#[inline]
unsafe extern "C" fn ts_calloc(mut count: size_t, mut size: size_t)
 -> *mut libc::c_void {
    let mut result: *mut libc::c_void = calloc(count, size);
    if count > 0 as libc::c_int as libc::c_ulong && result.is_null() {
        fprintf(stderr,
                b"tree-sitter failed to allocate %lu bytes\x00" as *const u8
                    as *const libc::c_char, count.wrapping_mul(size));
        exit(1 as libc::c_int);
    }
    return result;
}
#[inline]
unsafe extern "C" fn ts_realloc(mut buffer: *mut libc::c_void,
                                mut size: size_t) -> *mut libc::c_void {
    let mut result: *mut libc::c_void = realloc(buffer, size);
    if size > 0 as libc::c_int as libc::c_ulong && result.is_null() {
        fprintf(stderr,
                b"tree-sitter failed to reallocate %lu bytes\x00" as *const u8
                    as *const libc::c_char, size);
        exit(1 as libc::c_int);
    }
    return result;
}
#[inline]
unsafe extern "C" fn ts_free(mut buffer: *mut libc::c_void) { free(buffer); }
#[inline]
unsafe extern "C" fn atomic_inc(mut p: *mut uint32_t) -> uint32_t {
    let fresh0 = p;
    let fresh1 = 1 as libc::c_uint;
    return ::std::intrinsics::atomic_xadd(fresh0, fresh1) + fresh1;
}
#[inline]
unsafe extern "C" fn atomic_dec(mut p: *mut uint32_t) -> uint32_t {
    let fresh2 = p;
    let fresh3 = 1 as libc::c_uint;
    return ::std::intrinsics::atomic_xsub(fresh2, fresh3) - fresh3;
}
#[inline]
unsafe extern "C" fn point__new(mut row: libc::c_uint,
                                mut column: libc::c_uint) -> TSPoint {
    let mut result: TSPoint =
        { let mut init = TSPoint{row: row, column: column,}; init };
    return result;
}
#[inline]
unsafe extern "C" fn point_add(mut a: TSPoint, mut b: TSPoint) -> TSPoint {
    if b.row > 0 as libc::c_int as libc::c_uint {
        return point__new(a.row.wrapping_add(b.row), b.column)
    } else { return point__new(a.row, a.column.wrapping_add(b.column)) };
}
#[inline]
unsafe extern "C" fn point_sub(mut a: TSPoint, mut b: TSPoint) -> TSPoint {
    if a.row > b.row {
        return point__new(a.row.wrapping_sub(b.row), a.column)
    } else {
        return point__new(0 as libc::c_int as libc::c_uint,
                          a.column.wrapping_sub(b.column))
    };
}
#[inline]
unsafe extern "C" fn length_add(mut len1: Length, mut len2: Length)
 -> Length {
    let mut result: Length =
        Length{bytes: 0, extent: TSPoint{row: 0, column: 0,},};
    result.bytes = len1.bytes.wrapping_add(len2.bytes);
    result.extent = point_add(len1.extent, len2.extent);
    return result;
}
#[inline]
unsafe extern "C" fn length_sub(mut len1: Length, mut len2: Length)
 -> Length {
    let mut result: Length =
        Length{bytes: 0, extent: TSPoint{row: 0, column: 0,},};
    result.bytes = len1.bytes.wrapping_sub(len2.bytes);
    result.extent = point_sub(len1.extent, len2.extent);
    return result;
}
#[inline]
unsafe extern "C" fn length_zero() -> Length {
    let mut result: Length =
        {
            let mut init =
                Length{bytes: 0 as libc::c_int as uint32_t,
                       extent:
                           {
                               let mut init =
                                   TSPoint{row: 0 as libc::c_int as uint32_t,
                                           column:
                                               0 as libc::c_int as uint32_t,};
                               init
                           },};
            init
        };
    return result;
}
#[inline]
unsafe extern "C" fn array__delete(mut self_0: *mut VoidArray) {
    ts_free((*self_0).contents);
    (*self_0).contents = 0 as *mut libc::c_void;
    (*self_0).size = 0 as libc::c_int as uint32_t;
    (*self_0).capacity = 0 as libc::c_int as uint32_t;
}
#[inline]
unsafe extern "C" fn array__reserve(mut self_0: *mut VoidArray,
                                    mut element_size: size_t,
                                    mut new_capacity: uint32_t) {
    if new_capacity > (*self_0).capacity {
        if !(*self_0).contents.is_null() {
            (*self_0).contents =
                ts_realloc((*self_0).contents,
                           (new_capacity as
                                libc::c_ulong).wrapping_mul(element_size))
        } else {
            (*self_0).contents =
                ts_calloc(new_capacity as size_t, element_size)
        }
        (*self_0).capacity = new_capacity
    };
}
#[inline]
unsafe extern "C" fn array__grow(mut self_0: *mut VoidArray,
                                 mut count: size_t,
                                 mut element_size: size_t) {
    let mut new_size: size_t =
        ((*self_0).size as libc::c_ulong).wrapping_add(count);
    if new_size > (*self_0).capacity as libc::c_ulong {
        let mut new_capacity: size_t =
            (*self_0).capacity.wrapping_mul(2 as libc::c_int as libc::c_uint)
                as size_t;
        if new_capacity < 8 as libc::c_int as libc::c_ulong {
            new_capacity = 8 as libc::c_int as size_t
        }
        if new_capacity < new_size { new_capacity = new_size }
        array__reserve(self_0, element_size, new_capacity as uint32_t);
    };
}
static mut TS_TREE_STATE_NONE: TSStateId =
    (32767 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int) as TSStateId;
#[inline]
unsafe extern "C" fn ts_subtree_has_external_tokens(mut self_0: Subtree)
 -> bool {
    return if self_0.data.is_inline() as libc::c_int != 0 {
               0 as libc::c_int
           } else { (*self_0.ptr).has_external_tokens() as libc::c_int } != 0;
}
#[inline]
unsafe extern "C" fn ts_subtree_extra(mut self_0: Subtree) -> bool {
    return if self_0.data.is_inline() as libc::c_int != 0 {
               self_0.data.extra() as libc::c_int
           } else { (*self_0.ptr).extra() as libc::c_int } != 0;
}
#[inline]
unsafe extern "C" fn ts_subtree_repeat_depth(mut self_0: Subtree)
 -> uint32_t {
    return if self_0.data.is_inline() as libc::c_int != 0 {
               0 as libc::c_int as libc::c_uint
           } else {
               (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.repeat_depth
           };
}
#[inline]
unsafe extern "C" fn ts_subtree_symbol(mut self_0: Subtree) -> TSSymbol {
    return if self_0.data.is_inline() as libc::c_int != 0 {
               self_0.data.symbol as libc::c_int
           } else { (*self_0.ptr).symbol as libc::c_int } as TSSymbol;
}
#[inline]
unsafe extern "C" fn ts_subtree_fragile_right(mut self_0: Subtree) -> bool {
    return if self_0.data.is_inline() as libc::c_int != 0 {
               0 as libc::c_int
           } else { (*self_0.ptr).fragile_right() as libc::c_int } != 0;
}
#[inline]
unsafe extern "C" fn ts_subtree_fragile_left(mut self_0: Subtree) -> bool {
    return if self_0.data.is_inline() as libc::c_int != 0 {
               0 as libc::c_int
           } else { (*self_0.ptr).fragile_left() as libc::c_int } != 0;
}
#[inline]
unsafe extern "C" fn ts_subtree_leaf_parse_state(mut self_0: Subtree)
 -> TSStateId {
    if self_0.data.is_inline() { return self_0.data.parse_state }
    if (*self_0.ptr).child_count == 0 as libc::c_int as libc::c_uint {
        return (*self_0.ptr).parse_state
    }
    return (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.first_leaf.parse_state;
}
#[inline]
unsafe extern "C" fn ts_subtree_leaf_symbol(mut self_0: Subtree) -> TSSymbol {
    if self_0.data.is_inline() { return self_0.data.symbol as TSSymbol }
    if (*self_0.ptr).child_count == 0 as libc::c_int as libc::c_uint {
        return (*self_0.ptr).symbol
    }
    return (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.first_leaf.symbol;
}
#[inline]
unsafe extern "C" fn ts_subtree_child_count(mut self_0: Subtree) -> uint32_t {
    return if self_0.data.is_inline() as libc::c_int != 0 {
               0 as libc::c_int as libc::c_uint
           } else { (*self_0.ptr).child_count };
}
#[inline]
unsafe extern "C" fn ts_subtree_visible(mut self_0: Subtree) -> bool {
    return if self_0.data.is_inline() as libc::c_int != 0 {
               self_0.data.visible() as libc::c_int
           } else { (*self_0.ptr).visible() as libc::c_int } != 0;
}
#[inline]
unsafe extern "C" fn ts_subtree_parse_state(mut self_0: Subtree)
 -> TSStateId {
    return if self_0.data.is_inline() as libc::c_int != 0 {
               self_0.data.parse_state as libc::c_int
           } else { (*self_0.ptr).parse_state as libc::c_int } as TSStateId;
}
#[inline]
unsafe extern "C" fn ts_subtree_named(mut self_0: Subtree) -> bool {
    return if self_0.data.is_inline() as libc::c_int != 0 {
               self_0.data.named() as libc::c_int
           } else { (*self_0.ptr).named() as libc::c_int } != 0;
}
#[inline]
unsafe extern "C" fn ts_subtree_node_count(mut self_0: Subtree) -> uint32_t {
    return if self_0.data.is_inline() as libc::c_int != 0 ||
                  (*self_0.ptr).child_count ==
                      0 as libc::c_int as libc::c_uint {
               1 as libc::c_int as libc::c_uint
           } else { (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.node_count };
}
#[inline]
unsafe extern "C" fn ts_subtree_dynamic_precedence(mut self_0: Subtree)
 -> int32_t {
    return if self_0.data.is_inline() as libc::c_int != 0 ||
                  (*self_0.ptr).child_count ==
                      0 as libc::c_int as libc::c_uint {
               0 as libc::c_int
           } else {
               (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.dynamic_precedence
           };
}
#[inline]
unsafe extern "C" fn ts_subtree_error_cost(mut self_0: Subtree) -> uint32_t {
    if ts_subtree_missing(self_0) {
        return (110 as libc::c_int + 500 as libc::c_int) as uint32_t
    } else {
        return if self_0.data.is_inline() as libc::c_int != 0 {
                   0 as libc::c_int as libc::c_uint
               } else { (*self_0.ptr).error_cost }
    };
}
#[inline]
unsafe extern "C" fn ts_subtree_missing(mut self_0: Subtree) -> bool {
    return if self_0.data.is_inline() as libc::c_int != 0 {
               self_0.data.is_missing() as libc::c_int
           } else { (*self_0.ptr).is_missing() as libc::c_int } != 0;
}
#[inline]
unsafe extern "C" fn ts_subtree_lookahead_bytes(mut self_0: Subtree)
 -> uint32_t {
    return if self_0.data.is_inline() as libc::c_int != 0 {
               self_0.data.lookahead_bytes() as libc::c_uint
           } else { (*self_0.ptr).lookahead_bytes };
}
#[inline]
unsafe extern "C" fn ts_subtree_total_size(mut self_0: Subtree) -> Length {
    return length_add(ts_subtree_padding(self_0), ts_subtree_size(self_0));
}
#[inline]
unsafe extern "C" fn ts_subtree_size(mut self_0: Subtree) -> Length {
    if self_0.data.is_inline() {
        let mut result: Length =
            {
                let mut init =
                    Length{bytes: self_0.data.size_bytes as uint32_t,
                           extent:
                               {
                                   let mut init =
                                       TSPoint{row:
                                                   0 as libc::c_int as
                                                       uint32_t,
                                               column:
                                                   self_0.data.size_bytes as
                                                       uint32_t,};
                                   init
                               },};
                init
            };
        return result
    } else { return (*self_0.ptr).size };
}
#[inline]
unsafe extern "C" fn ts_subtree_padding(mut self_0: Subtree) -> Length {
    if self_0.data.is_inline() {
        let mut result: Length =
            {
                let mut init =
                    Length{bytes: self_0.data.padding_bytes as uint32_t,
                           extent:
                               {
                                   let mut init =
                                       TSPoint{row:
                                                   self_0.data.padding_rows()
                                                       as uint32_t,
                                               column:
                                                   self_0.data.padding_columns
                                                       as uint32_t,};
                                   init
                               },};
                init
            };
        return result
    } else { return (*self_0.ptr).padding };
}
#[inline]
unsafe extern "C" fn ts_subtree_has_changes(mut self_0: Subtree) -> bool {
    return if self_0.data.is_inline() as libc::c_int != 0 {
               self_0.data.has_changes() as libc::c_int
           } else { (*self_0.ptr).has_changes() as libc::c_int } != 0;
}
#[inline]
unsafe extern "C" fn ts_subtree_production_id(mut self_0: Subtree)
 -> uint16_t {
    if ts_subtree_child_count(self_0) > 0 as libc::c_int as libc::c_uint {
        return (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.production_id
    } else { return 0 as libc::c_int as uint16_t };
}
#[inline]
unsafe extern "C" fn ts_subtree_total_bytes(mut self_0: Subtree) -> uint32_t {
    return ts_subtree_total_size(self_0).bytes;
}
#[inline]
unsafe extern "C" fn ts_subtree_is_error(mut self_0: Subtree) -> bool {
    return ts_subtree_symbol(self_0) as libc::c_int ==
               -(1 as libc::c_int) as TSSymbol as libc::c_int;
}
#[inline]
unsafe extern "C" fn ts_subtree_from_mut(mut self_0: MutableSubtree)
 -> Subtree {
    let mut result: Subtree =
        Subtree{data:
                    SubtreeInlineData{is_inline_visible_named_extra_has_changes_is_missing_is_keyword:
                                          [0; 1],
                                      symbol: 0,
                                      padding_bytes: 0,
                                      size_bytes: 0,
                                      padding_columns: 0,
                                      padding_rows_lookahead_bytes: [0; 1],
                                      parse_state: 0,},};
    result.data = self_0.data;
    return result;
}
#[inline]
unsafe extern "C" fn ts_subtree_to_mut_unsafe(mut self_0: Subtree)
 -> MutableSubtree {
    let mut result: MutableSubtree =
        MutableSubtree{data:
                           SubtreeInlineData{is_inline_visible_named_extra_has_changes_is_missing_is_keyword:
                                                 [0; 1],
                                             symbol: 0,
                                             padding_bytes: 0,
                                             size_bytes: 0,
                                             padding_columns: 0,
                                             padding_rows_lookahead_bytes:
                                                 [0; 1],
                                             parse_state: 0,},};
    result.data = self_0.data;
    return result;
}
#[inline]
unsafe extern "C" fn ts_language_alias_sequence(mut self_0: *const TSLanguage,
                                                mut production_id: uint32_t)
 -> *const TSSymbol {
    return if production_id > 0 as libc::c_int as libc::c_uint {
               (*self_0).alias_sequences.offset(production_id.wrapping_mul((*self_0).max_alias_sequence_length
                                                                               as
                                                                               libc::c_uint)
                                                    as isize)
           } else { 0 as *const TSSymbol };
}
#[inline]
unsafe extern "C" fn ts_language_field_map(mut self_0: *const TSLanguage,
                                           mut production_id: uint32_t,
                                           mut start:
                                               *mut *const TSFieldMapEntry,
                                           mut end:
                                               *mut *const TSFieldMapEntry) {
    if (*self_0).version < 10 as libc::c_int as libc::c_uint ||
           (*self_0).field_count == 0 as libc::c_int as libc::c_uint {
        *start = 0 as *const TSFieldMapEntry;
        *end = 0 as *const TSFieldMapEntry;
        return
    }
    let mut slice: TSFieldMapSlice =
        *(*self_0).field_map_slices.offset(production_id as isize);
    *start =
        &*(*self_0).field_map_entries.offset(slice.index as isize) as
            *const TSFieldMapEntry;
    *end =
        (&*(*self_0).field_map_entries.offset(slice.index as isize) as
             *const TSFieldMapEntry).offset(slice.length as libc::c_int as
                                                isize);
}
static mut empty_state: ExternalScannerState =
    {
        let mut init =
            ExternalScannerState{c2rust_unnamed:
                                     C2RustUnnamed_6{short_data:
                                                         [0 as libc::c_int as
                                                              libc::c_char, 0,
                                                          0, 0, 0, 0, 0, 0, 0,
                                                          0, 0, 0, 0, 0, 0, 0,
                                                          0, 0, 0, 0, 0, 0, 0,
                                                          0],},
                                 length: 0 as libc::c_int as uint32_t,};
        init
    };
// ExternalScannerState
#[no_mangle]
pub unsafe extern "C" fn ts_external_scanner_state_init(mut self_0:
                                                            *mut ExternalScannerState,
                                                        mut data:
                                                            *const libc::c_char,
                                                        mut length:
                                                            libc::c_uint) {
    (*self_0).length = length;
    if length as libc::c_ulong >
           ::std::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong {
        (*self_0).c2rust_unnamed.long_data =
            ts_malloc(length as size_t) as *mut libc::c_char;
        memcpy((*self_0).c2rust_unnamed.long_data as *mut libc::c_void,
               data as *const libc::c_void, length as libc::c_ulong);
    } else {
        memcpy((*self_0).c2rust_unnamed.short_data.as_mut_ptr() as
                   *mut libc::c_void, data as *const libc::c_void,
               length as libc::c_ulong);
    };
}
#[no_mangle]
pub unsafe extern "C" fn ts_external_scanner_state_copy(mut self_0:
                                                            *const ExternalScannerState)
 -> ExternalScannerState {
    let mut result: ExternalScannerState = *self_0;
    if (*self_0).length as libc::c_ulong >
           ::std::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong {
        result.c2rust_unnamed.long_data =
            ts_malloc((*self_0).length as size_t) as *mut libc::c_char;
        memcpy(result.c2rust_unnamed.long_data as *mut libc::c_void,
               (*self_0).c2rust_unnamed.long_data as *const libc::c_void,
               (*self_0).length as libc::c_ulong);
    }
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn ts_external_scanner_state_delete(mut self_0:
                                                              *mut ExternalScannerState) {
    if (*self_0).length as libc::c_ulong >
           ::std::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong {
        ts_free((*self_0).c2rust_unnamed.long_data as *mut libc::c_void);
    };
}
#[no_mangle]
pub unsafe extern "C" fn ts_external_scanner_state_data(mut self_0:
                                                            *const ExternalScannerState)
 -> *const libc::c_char {
    if (*self_0).length as libc::c_ulong >
           ::std::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong {
        return (*self_0).c2rust_unnamed.long_data
    } else { return (*self_0).c2rust_unnamed.short_data.as_ptr() };
}
#[no_mangle]
pub unsafe extern "C" fn ts_external_scanner_state_eq(mut a:
                                                          *const ExternalScannerState,
                                                      mut b:
                                                          *const ExternalScannerState)
 -> bool {
    return a == b ||
               (*a).length == (*b).length &&
                   memcmp(ts_external_scanner_state_data(a) as
                              *const libc::c_void,
                          ts_external_scanner_state_data(b) as
                              *const libc::c_void,
                          (*a).length as libc::c_ulong) == 0;
}
// SubtreeArray
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_array_copy(mut self_0: SubtreeArray,
                                               mut dest: *mut SubtreeArray) {
    (*dest).size = self_0.size;
    (*dest).capacity = self_0.capacity;
    (*dest).contents = self_0.contents;
    if self_0.capacity > 0 as libc::c_int as libc::c_uint {
        (*dest).contents =
            ts_calloc(self_0.capacity as size_t,
                      ::std::mem::size_of::<Subtree>() as libc::c_ulong) as
                *mut Subtree;
        memcpy((*dest).contents as *mut libc::c_void,
               self_0.contents as *const libc::c_void,
               (self_0.size as
                    libc::c_ulong).wrapping_mul(::std::mem::size_of::<Subtree>()
                                                    as libc::c_ulong));
        let mut i: uint32_t = 0 as libc::c_int as uint32_t;
        while i < self_0.size {
            ts_subtree_retain(*(*dest).contents.offset(i as isize));
            i = i.wrapping_add(1)
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_array_delete(mut pool: *mut SubtreePool,
                                                 mut self_0:
                                                     *mut SubtreeArray) {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*self_0).size {
        ts_subtree_release(pool, *(*self_0).contents.offset(i as isize));
        i = i.wrapping_add(1)
    }
    array__delete(self_0 as *mut VoidArray);
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_array_remove_trailing_extras(mut self_0:
                                                                     *mut SubtreeArray)
 -> SubtreeArray {
    let mut result: SubtreeArray =
        {
            let mut init =
                SubtreeArray{contents: 0 as *mut Subtree,
                             size: 0 as libc::c_int as uint32_t,
                             capacity: 0 as libc::c_int as uint32_t,};
            init
        };
    let mut i: uint32_t =
        (*self_0).size.wrapping_sub(1 as libc::c_int as libc::c_uint);
    while i.wrapping_add(1 as libc::c_int as libc::c_uint) >
              0 as libc::c_int as libc::c_uint {
        let mut child: Subtree = *(*self_0).contents.offset(i as isize);
        if !ts_subtree_extra(child) { break ; }
        array__grow(&mut result as *mut SubtreeArray as *mut VoidArray,
                    1 as libc::c_int as size_t,
                    ::std::mem::size_of::<Subtree>() as libc::c_ulong);
        let fresh4 = result.size;
        result.size = result.size.wrapping_add(1);
        *result.contents.offset(fresh4 as isize) = child;
        i = i.wrapping_sub(1)
    }
    (*self_0).size = i.wrapping_add(1 as libc::c_int as libc::c_uint);
    ts_subtree_array_reverse(&mut result);
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_array_reverse(mut self_0:
                                                      *mut SubtreeArray) {
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    let mut limit: uint32_t =
        (*self_0).size.wrapping_div(2 as libc::c_int as libc::c_uint);
    while i < limit {
        let mut reverse_index: size_t =
            (*self_0).size.wrapping_sub(1 as libc::c_int as
                                            libc::c_uint).wrapping_sub(i) as
                size_t;
        let mut swap: Subtree = *(*self_0).contents.offset(i as isize);
        *(*self_0).contents.offset(i as isize) =
            *(*self_0).contents.offset(reverse_index as isize);
        *(*self_0).contents.offset(reverse_index as isize) = swap;
        i = i.wrapping_add(1)
    };
}
// SubtreePool
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_pool_new(mut capacity: uint32_t)
 -> SubtreePool {
    let mut self_0: SubtreePool =
        {
            let mut init =
                SubtreePool{free_trees:
                                {
                                    let mut init =
                                        MutableSubtreeArray{contents:
                                                                0 as
                                                                    *mut MutableSubtree,
                                                            size:
                                                                0 as
                                                                    libc::c_int
                                                                    as
                                                                    uint32_t,
                                                            capacity:
                                                                0 as
                                                                    libc::c_int
                                                                    as
                                                                    uint32_t,};
                                    init
                                },
                            tree_stack:
                                {
                                    let mut init =
                                        MutableSubtreeArray{contents:
                                                                0 as
                                                                    *mut MutableSubtree,
                                                            size:
                                                                0 as
                                                                    libc::c_int
                                                                    as
                                                                    uint32_t,
                                                            capacity:
                                                                0 as
                                                                    libc::c_int
                                                                    as
                                                                    uint32_t,};
                                    init
                                },};
            init
        };
    array__reserve(&mut self_0.free_trees as *mut MutableSubtreeArray as
                       *mut VoidArray,
                   ::std::mem::size_of::<MutableSubtree>() as libc::c_ulong,
                   capacity);
    return self_0;
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_pool_delete(mut self_0:
                                                    *mut SubtreePool) {
    if !(*self_0).free_trees.contents.is_null() {
        let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
        while i < (*self_0).free_trees.size {
            ts_free((*(*self_0).free_trees.contents.offset(i as isize)).ptr as
                        *mut libc::c_void);
            i = i.wrapping_add(1)
        }
        array__delete(&mut (*self_0).free_trees as *mut MutableSubtreeArray as
                          *mut VoidArray);
    }
    if !(*self_0).tree_stack.contents.is_null() {
        array__delete(&mut (*self_0).tree_stack as *mut MutableSubtreeArray as
                          *mut VoidArray);
    };
}
unsafe extern "C" fn ts_subtree_pool_allocate(mut self_0: *mut SubtreePool)
 -> *mut SubtreeHeapData {
    if (*self_0).free_trees.size > 0 as libc::c_int as libc::c_uint {
        (*self_0).free_trees.size = (*self_0).free_trees.size.wrapping_sub(1);
        return (*(*self_0).free_trees.contents.offset((*self_0).free_trees.size
                                                          as isize)).ptr
    } else {
        return ts_malloc(::std::mem::size_of::<SubtreeHeapData>() as
                             libc::c_ulong) as *mut SubtreeHeapData
    };
}
unsafe extern "C" fn ts_subtree_pool_free(mut self_0: *mut SubtreePool,
                                          mut tree: *mut SubtreeHeapData) {
    if (*self_0).free_trees.capacity > 0 as libc::c_int as libc::c_uint &&
           (*self_0).free_trees.size.wrapping_add(1 as libc::c_int as
                                                      libc::c_uint) <=
               32 as libc::c_int as libc::c_uint {
        array__grow(&mut (*self_0).free_trees as *mut MutableSubtreeArray as
                        *mut VoidArray, 1 as libc::c_int as size_t,
                    ::std::mem::size_of::<MutableSubtree>() as libc::c_ulong);
        let fresh5 = (*self_0).free_trees.size;
        (*self_0).free_trees.size = (*self_0).free_trees.size.wrapping_add(1);
        *(*self_0).free_trees.contents.offset(fresh5 as isize) =
            MutableSubtree{ptr: tree,}
    } else { ts_free(tree as *mut libc::c_void); };
}
// Subtree
#[inline]
unsafe extern "C" fn ts_subtree_can_inline(mut padding: Length,
                                           mut size: Length,
                                           mut lookahead_bytes: uint32_t)
 -> bool {
    return padding.bytes < 255 as libc::c_int as libc::c_uint &&
               padding.extent.row < 16 as libc::c_int as libc::c_uint &&
               padding.extent.column < 255 as libc::c_int as libc::c_uint &&
               size.extent.row == 0 as libc::c_int as libc::c_uint &&
               size.extent.column < 255 as libc::c_int as libc::c_uint &&
               lookahead_bytes < 16 as libc::c_int as libc::c_uint;
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_new_leaf(mut pool: *mut SubtreePool,
                                             mut symbol: TSSymbol,
                                             mut padding: Length,
                                             mut size: Length,
                                             mut lookahead_bytes: uint32_t,
                                             mut parse_state: TSStateId,
                                             mut has_external_tokens: bool,
                                             mut is_keyword: bool,
                                             mut language: *const TSLanguage)
 -> Subtree {
    let mut metadata: TSSymbolMetadata =
        ts_language_symbol_metadata(language, symbol);
    let mut extra: bool = symbol as libc::c_int == 0 as libc::c_int;
    let mut is_inline: bool =
        symbol as libc::c_int <= 255 as libc::c_int && !has_external_tokens &&
            ts_subtree_can_inline(padding, size, lookahead_bytes) as
                libc::c_int != 0;
    if is_inline {
        return Subtree{data:
                           {
                               let mut init =
                                   SubtreeInlineData{is_inline_visible_named_extra_has_changes_is_missing_is_keyword:
                                                         [0; 1],
                                                     padding_rows_lookahead_bytes:
                                                         [0; 1],
                                                     symbol:
                                                         symbol as uint8_t,
                                                     padding_bytes:
                                                         padding.bytes as
                                                             uint8_t,
                                                     size_bytes:
                                                         size.bytes as
                                                             uint8_t,
                                                     padding_columns:
                                                         padding.extent.column
                                                             as uint8_t,
                                                     parse_state:
                                                         parse_state,};
                               init.set_is_inline(1 as libc::c_int != 0);
                               init.set_visible(metadata.visible());
                               init.set_named(metadata.named());
                               init.set_extra(extra);
                               init.set_has_changes(0 as libc::c_int != 0);
                               init.set_is_missing(0 as libc::c_int != 0);
                               init.set_is_keyword(is_keyword);
                               init.set_padding_rows(padding.extent.row as
                                                         uint8_t);
                               init.set_lookahead_bytes(lookahead_bytes as
                                                            uint8_t);
                               init
                           },}
    } else {
        let mut data: *mut SubtreeHeapData = ts_subtree_pool_allocate(pool);
        *data =
            {
                let mut init =
                    SubtreeHeapData{visible_named_extra_fragile_left_fragile_right_has_changes_has_external_tokens_is_missing_is_keyword:
                                        [0; 2],
                                    c2rust_padding: [0; 2],
                                    ref_count: 1 as libc::c_int as uint32_t,
                                    padding: padding,
                                    size: size,
                                    lookahead_bytes: lookahead_bytes,
                                    error_cost: 0 as libc::c_int as uint32_t,
                                    child_count: 0 as libc::c_int as uint32_t,
                                    symbol: symbol,
                                    parse_state: parse_state,
                                    c2rust_unnamed:
                                        C2RustUnnamed_5{c2rust_unnamed:
                                                            {
                                                                let mut init =
                                                                    C2RustUnnamed_7{children:
                                                                                        0
                                                                                            as
                                                                                            *mut Subtree,
                                                                                    visible_child_count:
                                                                                        0,
                                                                                    named_child_count:
                                                                                        0,
                                                                                    node_count:
                                                                                        0,
                                                                                    repeat_depth:
                                                                                        0,
                                                                                    dynamic_precedence:
                                                                                        0,
                                                                                    production_id:
                                                                                        0,
                                                                                    first_leaf:
                                                                                        {
                                                                                            let mut init =
                                                                                                C2RustUnnamed_8{symbol:
                                                                                                                    0
                                                                                                                        as
                                                                                                                        libc::c_int
                                                                                                                        as
                                                                                                                        TSSymbol,
                                                                                                                parse_state:
                                                                                                                    0
                                                                                                                        as
                                                                                                                        libc::c_int
                                                                                                                        as
                                                                                                                        TSStateId,};
                                                                                            init
                                                                                        },};
                                                                init
                                                            },},};
                init.set_visible(metadata.visible());
                init.set_named(metadata.named());
                init.set_extra(extra);
                init.set_fragile_left(0 as libc::c_int != 0);
                init.set_fragile_right(0 as libc::c_int != 0);
                init.set_has_changes(0 as libc::c_int != 0);
                init.set_has_external_tokens(has_external_tokens);
                init.set_is_missing(0 as libc::c_int != 0);
                init.set_is_keyword(is_keyword);
                init
            };
        return Subtree{ptr: data,}
    };
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_set_symbol(mut self_0:
                                                   *mut MutableSubtree,
                                               mut symbol: TSSymbol,
                                               mut language:
                                                   *const TSLanguage) {
    let mut metadata: TSSymbolMetadata =
        ts_language_symbol_metadata(language, symbol);
    if (*self_0).data.is_inline() {
        if (symbol as libc::c_int) < 255 as libc::c_int {
        } else {
            __assert_fail(b"symbol < UINT8_MAX\x00" as *const u8 as
                              *const libc::c_char,
                          b"lib/src/subtree.c\x00" as *const u8 as
                              *const libc::c_char,
                          224 as libc::c_int as libc::c_uint,
                          (*::std::mem::transmute::<&[u8; 75],
                                                    &[libc::c_char; 75]>(b"void ts_subtree_set_symbol(MutableSubtree *, TSSymbol, const TSLanguage *)\x00")).as_ptr());
        }
        (*self_0).data.symbol = symbol as uint8_t;
        (*self_0).data.set_named(metadata.named());
        (*self_0).data.set_visible(metadata.visible())
    } else {
        (*(*self_0).ptr).symbol = symbol;
        (*(*self_0).ptr).set_named(metadata.named());
        (*(*self_0).ptr).set_visible(metadata.visible())
    };
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_new_error(mut pool: *mut SubtreePool,
                                              mut lookahead_char: int32_t,
                                              mut padding: Length,
                                              mut size: Length,
                                              mut bytes_scanned: uint32_t,
                                              mut parse_state: TSStateId,
                                              mut language: *const TSLanguage)
 -> Subtree {
    let mut result: Subtree =
        ts_subtree_new_leaf(pool, -(1 as libc::c_int) as TSSymbol, padding,
                            size, bytes_scanned, parse_state,
                            0 as libc::c_int != 0, 0 as libc::c_int != 0,
                            language);
    let mut data: *mut SubtreeHeapData = result.ptr as *mut SubtreeHeapData;
    (*data).set_fragile_left(1 as libc::c_int != 0);
    (*data).set_fragile_right(1 as libc::c_int != 0);
    (*data).c2rust_unnamed.lookahead_char = lookahead_char;
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_make_mut(mut pool: *mut SubtreePool,
                                             mut self_0: Subtree)
 -> MutableSubtree {
    if self_0.data.is_inline() { return MutableSubtree{data: self_0.data,} }
    if (*self_0.ptr).ref_count == 1 as libc::c_int as libc::c_uint {
        return ts_subtree_to_mut_unsafe(self_0)
    }
    let mut result: *mut SubtreeHeapData = ts_subtree_pool_allocate(pool);
    memcpy(result as *mut libc::c_void, self_0.ptr as *const libc::c_void,
           ::std::mem::size_of::<SubtreeHeapData>() as libc::c_ulong);
    if (*result).child_count > 0 as libc::c_int as libc::c_uint {
        (*result).c2rust_unnamed.c2rust_unnamed.children =
            ts_calloc((*self_0.ptr).child_count as size_t,
                      ::std::mem::size_of::<Subtree>() as libc::c_ulong) as
                *mut Subtree;
        memcpy((*result).c2rust_unnamed.c2rust_unnamed.children as
                   *mut libc::c_void,
               (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.children as
                   *const libc::c_void,
               ((*result).child_count as
                    libc::c_ulong).wrapping_mul(::std::mem::size_of::<Subtree>()
                                                    as libc::c_ulong));
        let mut i: uint32_t = 0 as libc::c_int as uint32_t;
        while i < (*result).child_count {
            ts_subtree_retain(*(*result).c2rust_unnamed.c2rust_unnamed.children.offset(i
                                                                                           as
                                                                                           isize));
            i = i.wrapping_add(1)
        }
    } else if (*result).has_external_tokens() {
        (*result).c2rust_unnamed.external_scanner_state =
            ts_external_scanner_state_copy(&(*self_0.ptr).c2rust_unnamed.external_scanner_state)
    }
    ::std::ptr::write_volatile(&mut (*result).ref_count as *mut uint32_t,
                               1 as libc::c_int as uint32_t);
    ts_subtree_release(pool, self_0);
    return MutableSubtree{ptr: result,};
}
unsafe extern "C" fn ts_subtree__compress(mut self_0: MutableSubtree,
                                          mut count: libc::c_uint,
                                          mut language: *const TSLanguage,
                                          mut stack:
                                              *mut MutableSubtreeArray) {
    let mut initial_stack_size: libc::c_uint = (*stack).size;
    let mut tree: MutableSubtree = self_0;
    let mut symbol: TSSymbol = (*tree.ptr).symbol;
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    while i < count {
        if (*tree.ptr).ref_count > 1 as libc::c_int as libc::c_uint ||
               (*tree.ptr).child_count < 2 as libc::c_int as libc::c_uint {
            break ;
        }
        let mut child: MutableSubtree =
            ts_subtree_to_mut_unsafe(*(*tree.ptr).c2rust_unnamed.c2rust_unnamed.children.offset(0
                                                                                                    as
                                                                                                    libc::c_int
                                                                                                    as
                                                                                                    isize));
        if child.data.is_inline() as libc::c_int != 0 ||
               (*child.ptr).child_count < 2 as libc::c_int as libc::c_uint ||
               (*child.ptr).ref_count > 1 as libc::c_int as libc::c_uint ||
               (*child.ptr).symbol as libc::c_int != symbol as libc::c_int {
            break ;
        }
        let mut grandchild: MutableSubtree =
            ts_subtree_to_mut_unsafe(*(*child.ptr).c2rust_unnamed.c2rust_unnamed.children.offset(0
                                                                                                     as
                                                                                                     libc::c_int
                                                                                                     as
                                                                                                     isize));
        if grandchild.data.is_inline() as libc::c_int != 0 ||
               (*grandchild.ptr).child_count <
                   2 as libc::c_int as libc::c_uint ||
               (*grandchild.ptr).ref_count > 1 as libc::c_int as libc::c_uint
               ||
               (*grandchild.ptr).symbol as libc::c_int !=
                   symbol as libc::c_int {
            break ;
        }
        *(*tree.ptr).c2rust_unnamed.c2rust_unnamed.children.offset(0 as
                                                                       libc::c_int
                                                                       as
                                                                       isize)
            = ts_subtree_from_mut(grandchild);
        *(*child.ptr).c2rust_unnamed.c2rust_unnamed.children.offset(0 as
                                                                        libc::c_int
                                                                        as
                                                                        isize)
            =
            *(*grandchild.ptr).c2rust_unnamed.c2rust_unnamed.children.offset((*grandchild.ptr).child_count.wrapping_sub(1
                                                                                                                            as
                                                                                                                            libc::c_int
                                                                                                                            as
                                                                                                                            libc::c_uint)
                                                                                 as
                                                                                 isize);
        *(*grandchild.ptr).c2rust_unnamed.c2rust_unnamed.children.offset((*grandchild.ptr).child_count.wrapping_sub(1
                                                                                                                        as
                                                                                                                        libc::c_int
                                                                                                                        as
                                                                                                                        libc::c_uint)
                                                                             as
                                                                             isize)
            = ts_subtree_from_mut(child);
        array__grow(stack as *mut VoidArray, 1 as libc::c_int as size_t,
                    ::std::mem::size_of::<MutableSubtree>() as libc::c_ulong);
        let fresh6 = (*stack).size;
        (*stack).size = (*stack).size.wrapping_add(1);
        *(*stack).contents.offset(fresh6 as isize) = tree;
        tree = grandchild;
        i = i.wrapping_add(1)
    }
    while (*stack).size > initial_stack_size {
        (*stack).size = (*stack).size.wrapping_sub(1);
        tree = *(*stack).contents.offset((*stack).size as isize);
        let mut child_0: MutableSubtree =
            ts_subtree_to_mut_unsafe(*(*tree.ptr).c2rust_unnamed.c2rust_unnamed.children.offset(0
                                                                                                    as
                                                                                                    libc::c_int
                                                                                                    as
                                                                                                    isize));
        let mut grandchild_0: MutableSubtree =
            ts_subtree_to_mut_unsafe(*(*child_0.ptr).c2rust_unnamed.c2rust_unnamed.children.offset((*child_0.ptr).child_count.wrapping_sub(1
                                                                                                                                               as
                                                                                                                                               libc::c_int
                                                                                                                                               as
                                                                                                                                               libc::c_uint)
                                                                                                       as
                                                                                                       isize));
        ts_subtree_set_children(grandchild_0,
                                (*grandchild_0.ptr).c2rust_unnamed.c2rust_unnamed.children,
                                (*grandchild_0.ptr).child_count, language);
        ts_subtree_set_children(child_0,
                                (*child_0.ptr).c2rust_unnamed.c2rust_unnamed.children,
                                (*child_0.ptr).child_count, language);
        ts_subtree_set_children(tree,
                                (*tree.ptr).c2rust_unnamed.c2rust_unnamed.children,
                                (*tree.ptr).child_count, language);
    };
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_balance(mut self_0: Subtree,
                                            mut pool: *mut SubtreePool,
                                            mut language: *const TSLanguage) {
    (*pool).tree_stack.size = 0 as libc::c_int as uint32_t;
    if ts_subtree_child_count(self_0) > 0 as libc::c_int as libc::c_uint &&
           (*self_0.ptr).ref_count == 1 as libc::c_int as libc::c_uint {
        array__grow(&mut (*pool).tree_stack as *mut MutableSubtreeArray as
                        *mut VoidArray, 1 as libc::c_int as size_t,
                    ::std::mem::size_of::<MutableSubtree>() as libc::c_ulong);
        let fresh7 = (*pool).tree_stack.size;
        (*pool).tree_stack.size = (*pool).tree_stack.size.wrapping_add(1);
        *(*pool).tree_stack.contents.offset(fresh7 as isize) =
            ts_subtree_to_mut_unsafe(self_0)
    }
    while (*pool).tree_stack.size > 0 as libc::c_int as libc::c_uint {
        (*pool).tree_stack.size = (*pool).tree_stack.size.wrapping_sub(1);
        let mut tree: MutableSubtree =
            *(*pool).tree_stack.contents.offset((*pool).tree_stack.size as
                                                    isize);
        if (*tree.ptr).c2rust_unnamed.c2rust_unnamed.repeat_depth >
               0 as libc::c_int as libc::c_uint {
            let mut child1: Subtree =
                *(*tree.ptr).c2rust_unnamed.c2rust_unnamed.children.offset(0
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               isize);
            let mut child2: Subtree =
                *(*tree.ptr).c2rust_unnamed.c2rust_unnamed.children.offset((*tree.ptr).child_count.wrapping_sub(1
                                                                                                                    as
                                                                                                                    libc::c_int
                                                                                                                    as
                                                                                                                    libc::c_uint)
                                                                               as
                                                                               isize);
            let mut repeat_delta: libc::c_long =
                ts_subtree_repeat_depth(child1) as libc::c_long -
                    ts_subtree_repeat_depth(child2) as libc::c_long;
            if repeat_delta > 0 as libc::c_int as libc::c_long {
                let mut n: libc::c_uint = repeat_delta as libc::c_uint;
                let mut i: libc::c_uint =
                    n.wrapping_div(2 as libc::c_int as libc::c_uint);
                while i > 0 as libc::c_int as libc::c_uint {
                    ts_subtree__compress(tree, i, language,
                                         &mut (*pool).tree_stack);
                    n = n.wrapping_sub(i);
                    i = i.wrapping_div(2 as libc::c_int as libc::c_uint)
                }
            }
        }
        let mut i_0: uint32_t = 0 as libc::c_int as uint32_t;
        while i_0 < (*tree.ptr).child_count {
            let mut child: Subtree =
                *(*tree.ptr).c2rust_unnamed.c2rust_unnamed.children.offset(i_0
                                                                               as
                                                                               isize);
            if ts_subtree_child_count(child) >
                   0 as libc::c_int as libc::c_uint &&
                   (*child.ptr).ref_count == 1 as libc::c_int as libc::c_uint
               {
                array__grow(&mut (*pool).tree_stack as
                                *mut MutableSubtreeArray as *mut VoidArray,
                            1 as libc::c_int as size_t,
                            ::std::mem::size_of::<MutableSubtree>() as
                                libc::c_ulong);
                let fresh8 = (*pool).tree_stack.size;
                (*pool).tree_stack.size =
                    (*pool).tree_stack.size.wrapping_add(1);
                *(*pool).tree_stack.contents.offset(fresh8 as isize) =
                    ts_subtree_to_mut_unsafe(child)
            }
            i_0 = i_0.wrapping_add(1)
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_set_children(mut self_0: MutableSubtree,
                                                 mut children: *mut Subtree,
                                                 mut child_count: uint32_t,
                                                 mut language:
                                                     *const TSLanguage) {
    if !self_0.data.is_inline() {
    } else {
        __assert_fail(b"!self.data.is_inline\x00" as *const u8 as
                          *const libc::c_char,
                      b"lib/src/subtree.c\x00" as *const u8 as
                          *const libc::c_char,
                      347 as libc::c_int as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 86],
                                                &[libc::c_char; 86]>(b"void ts_subtree_set_children(MutableSubtree, Subtree *, uint32_t, const TSLanguage *)\x00")).as_ptr());
    }
    if (*self_0.ptr).child_count > 0 as libc::c_int as libc::c_uint &&
           children != (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.children {
        ts_free((*self_0.ptr).c2rust_unnamed.c2rust_unnamed.children as
                    *mut libc::c_void);
    }
    (*self_0.ptr).child_count = child_count;
    (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.children = children;
    (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.named_child_count =
        0 as libc::c_int as uint32_t;
    (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.visible_child_count =
        0 as libc::c_int as uint32_t;
    (*self_0.ptr).error_cost = 0 as libc::c_int as uint32_t;
    (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.repeat_depth =
        0 as libc::c_int as uint32_t;
    (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.node_count =
        1 as libc::c_int as uint32_t;
    (*self_0.ptr).set_has_external_tokens(0 as libc::c_int != 0);
    (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.dynamic_precedence =
        0 as libc::c_int;
    let mut non_extra_index: uint32_t = 0 as libc::c_int as uint32_t;
    let mut alias_sequence: *const TSSymbol =
        ts_language_alias_sequence(language,
                                   (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.production_id
                                       as uint32_t);
    let mut lookahead_end_byte: uint32_t = 0 as libc::c_int as uint32_t;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    while i < (*self_0.ptr).child_count {
        let mut child: Subtree =
            *(*self_0.ptr).c2rust_unnamed.c2rust_unnamed.children.offset(i as
                                                                             isize);
        if i == 0 as libc::c_int as libc::c_uint {
            (*self_0.ptr).padding = ts_subtree_padding(child);
            (*self_0.ptr).size = ts_subtree_size(child)
        } else {
            (*self_0.ptr).size =
                length_add((*self_0.ptr).size, ts_subtree_total_size(child))
        }
        let mut child_lookahead_end_byte: uint32_t =
            (*self_0.ptr).padding.bytes.wrapping_add((*self_0.ptr).size.bytes).wrapping_add(ts_subtree_lookahead_bytes(child));
        if child_lookahead_end_byte > lookahead_end_byte {
            lookahead_end_byte = child_lookahead_end_byte
        }
        if ts_subtree_symbol(child) as libc::c_int !=
               -(1 as libc::c_int) as TSSymbol as libc::c_int -
                   1 as libc::c_int {
            (*self_0.ptr).error_cost =
                ((*self_0.ptr).error_cost as
                     libc::c_uint).wrapping_add(ts_subtree_error_cost(child))
                    as uint32_t as uint32_t
        }
        (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.dynamic_precedence +=
            ts_subtree_dynamic_precedence(child);
        (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.node_count =
            ((*self_0.ptr).c2rust_unnamed.c2rust_unnamed.node_count as
                 libc::c_uint).wrapping_add(ts_subtree_node_count(child)) as
                uint32_t as uint32_t;
        if !alias_sequence.is_null() &&
               *alias_sequence.offset(non_extra_index as isize) as libc::c_int
                   != 0 as libc::c_int && !ts_subtree_extra(child) {
            (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.visible_child_count =
                (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.visible_child_count.wrapping_add(1);
            if ts_language_symbol_metadata(language,
                                           *alias_sequence.offset(non_extra_index
                                                                      as
                                                                      isize)).named()
               {
                (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.named_child_count
                    =
                    (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.named_child_count.wrapping_add(1)
            }
        } else if ts_subtree_visible(child) {
            (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.visible_child_count =
                (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.visible_child_count.wrapping_add(1);
            if ts_subtree_named(child) {
                (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.named_child_count
                    =
                    (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.named_child_count.wrapping_add(1)
            }
        } else if ts_subtree_child_count(child) >
                      0 as libc::c_int as libc::c_uint {
            (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.visible_child_count =
                ((*self_0.ptr).c2rust_unnamed.c2rust_unnamed.visible_child_count
                     as
                     libc::c_uint).wrapping_add((*child.ptr).c2rust_unnamed.c2rust_unnamed.visible_child_count)
                    as uint32_t as uint32_t;
            (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.named_child_count =
                ((*self_0.ptr).c2rust_unnamed.c2rust_unnamed.named_child_count
                     as
                     libc::c_uint).wrapping_add((*child.ptr).c2rust_unnamed.c2rust_unnamed.named_child_count)
                    as uint32_t as uint32_t
        }
        if ts_subtree_has_external_tokens(child) {
            (*self_0.ptr).set_has_external_tokens(1 as libc::c_int != 0)
        }
        if ts_subtree_is_error(child) {
            (*self_0.ptr).set_fragile_right(1 as libc::c_int != 0);
            (*self_0.ptr).set_fragile_left((*self_0.ptr).fragile_right());
            (*self_0.ptr).parse_state = TS_TREE_STATE_NONE
        }
        if !ts_subtree_extra(child) {
            non_extra_index = non_extra_index.wrapping_add(1)
        }
        i = i.wrapping_add(1)
    }
    (*self_0.ptr).lookahead_bytes =
        lookahead_end_byte.wrapping_sub((*self_0.ptr).size.bytes).wrapping_sub((*self_0.ptr).padding.bytes);
    if (*self_0.ptr).symbol as libc::c_int ==
           -(1 as libc::c_int) as TSSymbol as libc::c_int ||
           (*self_0.ptr).symbol as libc::c_int ==
               -(1 as libc::c_int) as TSSymbol as libc::c_int -
                   1 as libc::c_int {
        (*self_0.ptr).error_cost =
            ((*self_0.ptr).error_cost as
                 libc::c_uint).wrapping_add((500 as libc::c_int as
                                                 libc::c_uint).wrapping_add((1
                                                                                 as
                                                                                 libc::c_int
                                                                                 as
                                                                                 libc::c_uint).wrapping_mul((*self_0.ptr).size.bytes)).wrapping_add((30
                                                                                                                                                         as
                                                                                                                                                         libc::c_int
                                                                                                                                                         as
                                                                                                                                                         libc::c_uint).wrapping_mul((*self_0.ptr).size.extent.row)))
                as uint32_t as uint32_t;
        let mut i_0: uint32_t = 0 as libc::c_int as uint32_t;
        while i_0 < (*self_0.ptr).child_count {
            let mut child_0: Subtree =
                *(*self_0.ptr).c2rust_unnamed.c2rust_unnamed.children.offset(i_0
                                                                                 as
                                                                                 isize);
            let mut grandchild_count: uint32_t =
                ts_subtree_child_count(child_0);
            if !ts_subtree_extra(child_0) {
                if !(ts_subtree_is_error(child_0) as libc::c_int != 0 &&
                         grandchild_count == 0 as libc::c_int as libc::c_uint)
                   {
                    if ts_subtree_visible(child_0) {
                        (*self_0.ptr).error_cost =
                            ((*self_0.ptr).error_cost as
                                 libc::c_uint).wrapping_add(100 as libc::c_int
                                                                as
                                                                libc::c_uint)
                                as uint32_t as uint32_t
                    } else if grandchild_count >
                                  0 as libc::c_int as libc::c_uint {
                        (*self_0.ptr).error_cost =
                            ((*self_0.ptr).error_cost as
                                 libc::c_uint).wrapping_add((100 as
                                                                 libc::c_int
                                                                 as
                                                                 libc::c_uint).wrapping_mul((*child_0.ptr).c2rust_unnamed.c2rust_unnamed.visible_child_count))
                                as uint32_t as uint32_t
                    }
                }
            }
            i_0 = i_0.wrapping_add(1)
        }
    }
    if (*self_0.ptr).child_count > 0 as libc::c_int as libc::c_uint {
        let mut first_child: Subtree =
            *(*self_0.ptr).c2rust_unnamed.c2rust_unnamed.children.offset(0 as
                                                                             libc::c_int
                                                                             as
                                                                             isize);
        let mut last_child: Subtree =
            *(*self_0.ptr).c2rust_unnamed.c2rust_unnamed.children.offset((*self_0.ptr).child_count.wrapping_sub(1
                                                                                                                    as
                                                                                                                    libc::c_int
                                                                                                                    as
                                                                                                                    libc::c_uint)
                                                                             as
                                                                             isize);
        (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.first_leaf.symbol =
            ts_subtree_leaf_symbol(first_child);
        (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.first_leaf.parse_state =
            ts_subtree_leaf_parse_state(first_child);
        if ts_subtree_fragile_left(first_child) {
            (*self_0.ptr).set_fragile_left(1 as libc::c_int != 0)
        }
        if ts_subtree_fragile_right(last_child) {
            (*self_0.ptr).set_fragile_right(1 as libc::c_int != 0)
        }
        if (*self_0.ptr).child_count >= 2 as libc::c_int as libc::c_uint &&
               !(*self_0.ptr).visible() && !(*self_0.ptr).named() &&
               ts_subtree_symbol(first_child) as libc::c_int ==
                   (*self_0.ptr).symbol as libc::c_int {
            if ts_subtree_repeat_depth(first_child) >
                   ts_subtree_repeat_depth(last_child) {
                (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.repeat_depth =
                    ts_subtree_repeat_depth(first_child).wrapping_add(1 as
                                                                          libc::c_int
                                                                          as
                                                                          libc::c_uint)
            } else {
                (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.repeat_depth =
                    ts_subtree_repeat_depth(last_child).wrapping_add(1 as
                                                                         libc::c_int
                                                                         as
                                                                         libc::c_uint)
            }
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_new_node(mut pool: *mut SubtreePool,
                                             mut symbol: TSSymbol,
                                             mut children: *mut SubtreeArray,
                                             mut production_id: libc::c_uint,
                                             mut language: *const TSLanguage)
 -> MutableSubtree {
    let mut metadata: TSSymbolMetadata =
        ts_language_symbol_metadata(language, symbol);
    let mut fragile: bool =
        symbol as libc::c_int ==
            -(1 as libc::c_int) as TSSymbol as libc::c_int ||
            symbol as libc::c_int ==
                -(1 as libc::c_int) as TSSymbol as libc::c_int -
                    1 as libc::c_int;
    let mut data: *mut SubtreeHeapData = ts_subtree_pool_allocate(pool);
    *data =
        {
            let mut init =
                SubtreeHeapData{visible_named_extra_fragile_left_fragile_right_has_changes_has_external_tokens_is_missing_is_keyword:
                                    [0; 2],
                                c2rust_padding: [0; 2],
                                ref_count: 1 as libc::c_int as uint32_t,
                                padding:
                                    Length{bytes: 0,
                                           extent:
                                               TSPoint{row: 0, column: 0,},},
                                size:
                                    Length{bytes: 0,
                                           extent:
                                               TSPoint{row: 0, column: 0,},},
                                lookahead_bytes: 0,
                                error_cost: 0,
                                child_count: 0,
                                symbol: symbol,
                                parse_state: 0,
                                c2rust_unnamed:
                                    C2RustUnnamed_5{c2rust_unnamed:
                                                        {
                                                            let mut init =
                                                                C2RustUnnamed_7{children:
                                                                                    0
                                                                                        as
                                                                                        *mut Subtree,
                                                                                visible_child_count:
                                                                                    0,
                                                                                named_child_count:
                                                                                    0,
                                                                                node_count:
                                                                                    0
                                                                                        as
                                                                                        libc::c_int
                                                                                        as
                                                                                        uint32_t,
                                                                                repeat_depth:
                                                                                    0,
                                                                                dynamic_precedence:
                                                                                    0,
                                                                                production_id:
                                                                                    production_id
                                                                                        as
                                                                                        uint16_t,
                                                                                first_leaf:
                                                                                    {
                                                                                        let mut init =
                                                                                            C2RustUnnamed_8{symbol:
                                                                                                                0
                                                                                                                    as
                                                                                                                    libc::c_int
                                                                                                                    as
                                                                                                                    TSSymbol,
                                                                                                            parse_state:
                                                                                                                0
                                                                                                                    as
                                                                                                                    libc::c_int
                                                                                                                    as
                                                                                                                    TSStateId,};
                                                                                        init
                                                                                    },};
                                                            init
                                                        },},};
            init.set_visible(metadata.visible());
            init.set_named(metadata.named());
            init.set_extra(false);
            init.set_fragile_left(fragile);
            init.set_fragile_right(fragile);
            init.set_has_changes(0 as libc::c_int != 0);
            init.set_has_external_tokens(false);
            init.set_is_missing(false);
            init.set_is_keyword(0 as libc::c_int != 0);
            init
        };
    let mut result: MutableSubtree = MutableSubtree{ptr: data,};
    ts_subtree_set_children(result, (*children).contents, (*children).size,
                            language);
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_new_error_node(mut pool: *mut SubtreePool,
                                                   mut children:
                                                       *mut SubtreeArray,
                                                   mut extra: bool,
                                                   mut language:
                                                       *const TSLanguage)
 -> Subtree {
    let mut result: MutableSubtree =
        ts_subtree_new_node(pool, -(1 as libc::c_int) as TSSymbol, children,
                            0 as libc::c_int as libc::c_uint, language);
    (*result.ptr).set_extra(extra);
    return ts_subtree_from_mut(result);
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_new_missing_leaf(mut pool:
                                                         *mut SubtreePool,
                                                     mut symbol: TSSymbol,
                                                     mut padding: Length,
                                                     mut language:
                                                         *const TSLanguage)
 -> Subtree {
    let mut result: Subtree =
        ts_subtree_new_leaf(pool, symbol, padding, length_zero(),
                            0 as libc::c_int as uint32_t,
                            0 as libc::c_int as TSStateId,
                            0 as libc::c_int != 0, 0 as libc::c_int != 0,
                            language);
    if result.data.is_inline() {
        result.data.set_is_missing(1 as libc::c_int != 0)
    } else {
        let ref mut fresh9 = *(result.ptr as *mut SubtreeHeapData);
        (*fresh9).set_is_missing(1 as libc::c_int != 0)
    }
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_retain(mut self_0: Subtree) {
    if self_0.data.is_inline() { return }
    if (*self_0.ptr).ref_count > 0 as libc::c_int as libc::c_uint {
    } else {
        __assert_fail(b"self.ptr->ref_count > 0\x00" as *const u8 as
                          *const libc::c_char,
                      b"lib/src/subtree.c\x00" as *const u8 as
                          *const libc::c_char,
                      511 as libc::c_int as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 32],
                                                &[libc::c_char; 32]>(b"void ts_subtree_retain(Subtree)\x00")).as_ptr());
    }
    atomic_inc(&(*self_0.ptr).ref_count as *const uint32_t as *mut uint32_t);
    if (*self_0.ptr).ref_count != 0 as libc::c_int as libc::c_uint {
    } else {
        __assert_fail(b"self.ptr->ref_count != 0\x00" as *const u8 as
                          *const libc::c_char,
                      b"lib/src/subtree.c\x00" as *const u8 as
                          *const libc::c_char,
                      513 as libc::c_int as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 32],
                                                &[libc::c_char; 32]>(b"void ts_subtree_retain(Subtree)\x00")).as_ptr());
    };
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_release(mut pool: *mut SubtreePool,
                                            mut self_0: Subtree) {
    if self_0.data.is_inline() { return }
    (*pool).tree_stack.size = 0 as libc::c_int as uint32_t;
    if (*self_0.ptr).ref_count > 0 as libc::c_int as libc::c_uint {
    } else {
        __assert_fail(b"self.ptr->ref_count > 0\x00" as *const u8 as
                          *const libc::c_char,
                      b"lib/src/subtree.c\x00" as *const u8 as
                          *const libc::c_char,
                      520 as libc::c_int as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 48],
                                                &[libc::c_char; 48]>(b"void ts_subtree_release(SubtreePool *, Subtree)\x00")).as_ptr());
    }
    if atomic_dec(&(*self_0.ptr).ref_count as *const uint32_t as
                      *mut uint32_t) == 0 as libc::c_int as libc::c_uint {
        array__grow(&mut (*pool).tree_stack as *mut MutableSubtreeArray as
                        *mut VoidArray, 1 as libc::c_int as size_t,
                    ::std::mem::size_of::<MutableSubtree>() as libc::c_ulong);
        let fresh10 = (*pool).tree_stack.size;
        (*pool).tree_stack.size = (*pool).tree_stack.size.wrapping_add(1);
        *(*pool).tree_stack.contents.offset(fresh10 as isize) =
            ts_subtree_to_mut_unsafe(self_0)
    }
    while (*pool).tree_stack.size > 0 as libc::c_int as libc::c_uint {
        (*pool).tree_stack.size = (*pool).tree_stack.size.wrapping_sub(1);
        let mut tree: MutableSubtree =
            *(*pool).tree_stack.contents.offset((*pool).tree_stack.size as
                                                    isize);
        if (*tree.ptr).child_count > 0 as libc::c_int as libc::c_uint {
            let mut i: uint32_t = 0 as libc::c_int as uint32_t;
            while i < (*tree.ptr).child_count {
                let mut child: Subtree =
                    *(*tree.ptr).c2rust_unnamed.c2rust_unnamed.children.offset(i
                                                                                   as
                                                                                   isize);
                if !child.data.is_inline() {
                    if (*child.ptr).ref_count >
                           0 as libc::c_int as libc::c_uint {
                    } else {
                        __assert_fail(b"child.ptr->ref_count > 0\x00" as
                                          *const u8 as *const libc::c_char,
                                      b"lib/src/subtree.c\x00" as *const u8 as
                                          *const libc::c_char,
                                      531 as libc::c_int as libc::c_uint,
                                      (*::std::mem::transmute::<&[u8; 48],
                                                                &[libc::c_char; 48]>(b"void ts_subtree_release(SubtreePool *, Subtree)\x00")).as_ptr());
                    }
                    if atomic_dec(&(*child.ptr).ref_count as *const uint32_t
                                      as *mut uint32_t) ==
                           0 as libc::c_int as libc::c_uint {
                        array__grow(&mut (*pool).tree_stack as
                                        *mut MutableSubtreeArray as
                                        *mut VoidArray,
                                    1 as libc::c_int as size_t,
                                    ::std::mem::size_of::<MutableSubtree>() as
                                        libc::c_ulong);
                        let fresh11 = (*pool).tree_stack.size;
                        (*pool).tree_stack.size =
                            (*pool).tree_stack.size.wrapping_add(1);
                        *(*pool).tree_stack.contents.offset(fresh11 as isize)
                            = ts_subtree_to_mut_unsafe(child)
                    }
                }
                i = i.wrapping_add(1)
            }
            ts_free((*tree.ptr).c2rust_unnamed.c2rust_unnamed.children as
                        *mut libc::c_void);
        } else if (*tree.ptr).has_external_tokens() {
            ts_external_scanner_state_delete(&mut (*tree.ptr).c2rust_unnamed.external_scanner_state);
        }
        ts_subtree_pool_free(pool, tree.ptr);
    };
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_eq(mut self_0: Subtree,
                                       mut other: Subtree) -> bool {
    if self_0.data.is_inline() as libc::c_int != 0 ||
           other.data.is_inline() as libc::c_int != 0 {
        return memcmp(&mut self_0 as *mut Subtree as *const libc::c_void,
                      &mut other as *mut Subtree as *const libc::c_void,
                      ::std::mem::size_of::<SubtreeInlineData>() as
                          libc::c_ulong) == 0 as libc::c_int
    }
    if !self_0.ptr.is_null() {
        if other.ptr.is_null() { return 0 as libc::c_int != 0 }
    } else { return other.ptr.is_null() }
    if (*self_0.ptr).symbol as libc::c_int !=
           (*other.ptr).symbol as libc::c_int {
        return 0 as libc::c_int != 0
    }
    if (*self_0.ptr).visible() as libc::c_int !=
           (*other.ptr).visible() as libc::c_int {
        return 0 as libc::c_int != 0
    }
    if (*self_0.ptr).named() as libc::c_int !=
           (*other.ptr).named() as libc::c_int {
        return 0 as libc::c_int != 0
    }
    if (*self_0.ptr).padding.bytes != (*other.ptr).padding.bytes {
        return 0 as libc::c_int != 0
    }
    if (*self_0.ptr).size.bytes != (*other.ptr).size.bytes {
        return 0 as libc::c_int != 0
    }
    if (*self_0.ptr).symbol as libc::c_int ==
           -(1 as libc::c_int) as TSSymbol as libc::c_int {
        return (*self_0.ptr).c2rust_unnamed.lookahead_char ==
                   (*other.ptr).c2rust_unnamed.lookahead_char
    }
    if (*self_0.ptr).child_count != (*other.ptr).child_count {
        return 0 as libc::c_int != 0
    }
    if (*self_0.ptr).child_count > 0 as libc::c_int as libc::c_uint {
        if (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.visible_child_count !=
               (*other.ptr).c2rust_unnamed.c2rust_unnamed.visible_child_count
           {
            return 0 as libc::c_int != 0
        }
        if (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.named_child_count !=
               (*other.ptr).c2rust_unnamed.c2rust_unnamed.named_child_count {
            return 0 as libc::c_int != 0
        }
        let mut i: uint32_t = 0 as libc::c_int as uint32_t;
        while i < (*self_0.ptr).child_count {
            if !ts_subtree_eq(*(*self_0.ptr).c2rust_unnamed.c2rust_unnamed.children.offset(i
                                                                                               as
                                                                                               isize),
                              *(*other.ptr).c2rust_unnamed.c2rust_unnamed.children.offset(i
                                                                                              as
                                                                                              isize))
               {
                return 0 as libc::c_int != 0
            }
            i = i.wrapping_add(1)
        }
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_compare(mut left: Subtree,
                                            mut right: Subtree)
 -> libc::c_int {
    if (ts_subtree_symbol(left) as libc::c_int) <
           ts_subtree_symbol(right) as libc::c_int {
        return -(1 as libc::c_int)
    }
    if (ts_subtree_symbol(right) as libc::c_int) <
           ts_subtree_symbol(left) as libc::c_int {
        return 1 as libc::c_int
    }
    if ts_subtree_child_count(left) < ts_subtree_child_count(right) {
        return -(1 as libc::c_int)
    }
    if ts_subtree_child_count(right) < ts_subtree_child_count(left) {
        return 1 as libc::c_int
    }
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    let mut n: uint32_t = ts_subtree_child_count(left);
    while i < n {
        let mut left_child: Subtree =
            *(*left.ptr).c2rust_unnamed.c2rust_unnamed.children.offset(i as
                                                                           isize);
        let mut right_child: Subtree =
            *(*right.ptr).c2rust_unnamed.c2rust_unnamed.children.offset(i as
                                                                            isize);
        match ts_subtree_compare(left_child, right_child) {
            -1 => { return -(1 as libc::c_int) }
            1 => { return 1 as libc::c_int }
            _ => { }
        }
        i = i.wrapping_add(1)
    }
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn ts_subtree_set_has_changes(mut self_0:
                                                    *mut MutableSubtree) {
    if (*self_0).data.is_inline() {
        (*self_0).data.set_has_changes(1 as libc::c_int != 0)
    } else { (*(*self_0).ptr).set_has_changes(1 as libc::c_int != 0) };
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_edit(mut self_0: Subtree,
                                         mut edit: *const TSInputEdit,
                                         mut pool: *mut SubtreePool)
 -> Subtree {
    let mut stack: C2RustUnnamed_9 =
        {
            let mut init =
                C2RustUnnamed_9{contents: 0 as *mut StackEntry,
                                size: 0 as libc::c_int as uint32_t,
                                capacity: 0 as libc::c_int as uint32_t,};
            init
        };
    array__grow(&mut stack as *mut C2RustUnnamed_9 as *mut VoidArray,
                1 as libc::c_int as size_t,
                ::std::mem::size_of::<StackEntry>() as libc::c_ulong);
    let fresh12 = stack.size;
    stack.size = stack.size.wrapping_add(1);
    *stack.contents.offset(fresh12 as isize) =
        {
            let mut init =
                StackEntry{tree: &mut self_0,
                           edit:
                               {
                                   let mut init =
                                       Edit{start:
                                                {
                                                    let mut init =
                                                        Length{bytes:
                                                                   (*edit).start_byte,
                                                               extent:
                                                                   (*edit).start_point,};
                                                    init
                                                },
                                            old_end:
                                                {
                                                    let mut init =
                                                        Length{bytes:
                                                                   (*edit).old_end_byte,
                                                               extent:
                                                                   (*edit).old_end_point,};
                                                    init
                                                },
                                            new_end:
                                                {
                                                    let mut init =
                                                        Length{bytes:
                                                                   (*edit).new_end_byte,
                                                               extent:
                                                                   (*edit).new_end_point,};
                                                    init
                                                },};
                                   init
                               },};
            init
        };
    while stack.size != 0 {
        stack.size = stack.size.wrapping_sub(1);
        let mut entry: StackEntry =
            *stack.contents.offset(stack.size as isize);
        let mut edit_0: Edit = entry.edit;
        let mut is_noop: bool =
            edit_0.old_end.bytes == edit_0.start.bytes &&
                edit_0.new_end.bytes == edit_0.start.bytes;
        let mut is_pure_insertion: bool =
            edit_0.old_end.bytes == edit_0.start.bytes;
        let mut size: Length = ts_subtree_size(*entry.tree);
        let mut padding: Length = ts_subtree_padding(*entry.tree);
        let mut lookahead_bytes: uint32_t =
            ts_subtree_lookahead_bytes(*entry.tree);
        let mut end_byte: uint32_t =
            padding.bytes.wrapping_add(size.bytes).wrapping_add(lookahead_bytes);
        if edit_0.start.bytes > end_byte ||
               is_noop as libc::c_int != 0 && edit_0.start.bytes == end_byte {
            continue ;
        }
        // If the edit is entirely within the space before this subtree, then shift this
    // subtree over according to the edit without changing its size.
        if edit_0.old_end.bytes <= padding.bytes {
            padding =
                length_add(edit_0.new_end,
                           length_sub(padding, edit_0.old_end))
        } else if edit_0.start.bytes < padding.bytes {
            size = length_sub(size, length_sub(edit_0.old_end, padding));
            padding = edit_0.new_end
        } else if edit_0.start.bytes == padding.bytes &&
                      is_pure_insertion as libc::c_int != 0 {
            padding = edit_0.new_end
        } else {
            // If the edit starts in the space before this subtree and extends into this subtree,
    // shrink the subtree's content to compensate for the change in the space before it.
            // If the edit is a pure insertion right at the start of the subtree,
    // shift the subtree over according to the insertion.
            // If the edit is within this subtree, resize the subtree to reflect the edit.
            let mut total_bytes: uint32_t =
                padding.bytes.wrapping_add(size.bytes);
            if edit_0.start.bytes < total_bytes ||
                   edit_0.start.bytes == total_bytes &&
                       is_pure_insertion as libc::c_int != 0 {
                size =
                    length_add(length_sub(edit_0.new_end, padding),
                               length_sub(size,
                                          length_sub(edit_0.old_end,
                                                     padding)))
            }
        }
        let mut result: MutableSubtree =
            ts_subtree_make_mut(pool, *entry.tree);
        if result.data.is_inline() {
            if ts_subtree_can_inline(padding, size, lookahead_bytes) {
                result.data.padding_bytes = padding.bytes as uint8_t;
                result.data.set_padding_rows(padding.extent.row as uint8_t);
                result.data.padding_columns =
                    padding.extent.column as uint8_t;
                result.data.size_bytes = size.bytes as uint8_t
            } else {
                let mut data: *mut SubtreeHeapData =
                    ts_subtree_pool_allocate(pool);
                ::std::ptr::write_volatile(&mut (*data).ref_count as
                                               *mut uint32_t,
                                           1 as libc::c_int as uint32_t);
                (*data).padding = padding;
                (*data).size = size;
                (*data).lookahead_bytes = lookahead_bytes;
                (*data).error_cost = 0 as libc::c_int as uint32_t;
                (*data).child_count = 0 as libc::c_int as uint32_t;
                (*data).symbol = result.data.symbol as TSSymbol;
                (*data).parse_state = result.data.parse_state;
                (*data).set_visible(result.data.visible());
                (*data).set_named(result.data.named());
                (*data).set_extra(result.data.extra());
                (*data).set_fragile_left(0 as libc::c_int != 0);
                (*data).set_fragile_right(0 as libc::c_int != 0);
                (*data).set_has_changes(0 as libc::c_int != 0);
                (*data).set_has_external_tokens(0 as libc::c_int != 0);
                (*data).set_is_missing(result.data.is_missing());
                (*data).set_is_keyword(result.data.is_keyword());
                result.ptr = data
            }
        } else { (*result.ptr).padding = padding; (*result.ptr).size = size }
        ts_subtree_set_has_changes(&mut result);
        *entry.tree = ts_subtree_from_mut(result);
        let mut child_left: Length =
            Length{bytes: 0, extent: TSPoint{row: 0, column: 0,},};
        let mut child_right: Length = length_zero();
        let mut i: uint32_t = 0 as libc::c_int as uint32_t;
        let mut n: uint32_t = ts_subtree_child_count(*entry.tree);
        while i < n {
            let mut child: *mut Subtree =
                &mut *(*result.ptr).c2rust_unnamed.c2rust_unnamed.children.offset(i
                                                                                      as
                                                                                      isize)
                    as *mut Subtree;
            let mut child_size: Length = ts_subtree_total_size(*child);
            child_left = child_right;
            child_right = length_add(child_left, child_size);
            // If this child ends before the edit, it is not affected.
            if !(child_right.bytes.wrapping_add(ts_subtree_lookahead_bytes(*child))
                     < edit_0.start.bytes) {
                // If this child starts after the edit, then we're done processing children.
                if child_left.bytes > edit_0.old_end.bytes ||
                       child_left.bytes == edit_0.old_end.bytes &&
                           child_size.bytes > 0 as libc::c_int as libc::c_uint
                           && i > 0 as libc::c_int as libc::c_uint {
                    break ;
                }
                // Transform edit into the child's coordinate space.
                let mut child_edit: Edit =
                    {
                        let mut init =
                            Edit{start: length_sub(edit_0.start, child_left),
                                 old_end:
                                     length_sub(edit_0.old_end, child_left),
                                 new_end:
                                     length_sub(edit_0.new_end, child_left),};
                        init
                    };
                // Clamp child_edit to the child's bounds.
                if edit_0.start.bytes < child_left.bytes {
                    child_edit.start = length_zero()
                }
                if edit_0.old_end.bytes < child_left.bytes {
                    child_edit.old_end = length_zero()
                }
                if edit_0.new_end.bytes < child_left.bytes {
                    child_edit.new_end = length_zero()
                }
                if edit_0.old_end.bytes > child_right.bytes {
                    child_edit.old_end = child_size
                }
                // Interpret all inserted text as applying to the *first* child that touches the edit.
      // Subsequent children are only never have any text inserted into them; they are only
      // shrunk to compensate for the edit.
                if child_right.bytes > edit_0.start.bytes ||
                       child_right.bytes == edit_0.start.bytes &&
                           is_pure_insertion as libc::c_int != 0 {
                    edit_0.new_end = edit_0.start
                } else {
                    // Children that occur before the edit are not reshaped by the edit.
                    child_edit.old_end = child_edit.start;
                    child_edit.new_end = child_edit.start
                }
                // Queue processing of this child's subtree.
                array__grow(&mut stack as *mut C2RustUnnamed_9 as
                                *mut VoidArray, 1 as libc::c_int as size_t,
                            ::std::mem::size_of::<StackEntry>() as
                                libc::c_ulong);
                let fresh13 = stack.size;
                stack.size = stack.size.wrapping_add(1);
                *stack.contents.offset(fresh13 as isize) =
                    {
                        let mut init =
                            StackEntry{tree: child, edit: child_edit,};
                        init
                    }
            }
            i = i.wrapping_add(1)
        }
    }
    array__delete(&mut stack as *mut C2RustUnnamed_9 as *mut VoidArray);
    return self_0;
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_last_external_token(mut tree: Subtree)
 -> Subtree {
    if !ts_subtree_has_external_tokens(tree) {
        return Subtree{ptr: 0 as *const SubtreeHeapData,}
    }
    while (*tree.ptr).child_count > 0 as libc::c_int as libc::c_uint {
        let mut i: uint32_t =
            (*tree.ptr).child_count.wrapping_sub(1 as libc::c_int as
                                                     libc::c_uint);
        while i.wrapping_add(1 as libc::c_int as libc::c_uint) >
                  0 as libc::c_int as libc::c_uint {
            let mut child: Subtree =
                *(*tree.ptr).c2rust_unnamed.c2rust_unnamed.children.offset(i
                                                                               as
                                                                               isize);
            if ts_subtree_has_external_tokens(child) {
                tree = child;
                break ;
            } else { i = i.wrapping_sub(1) }
        }
    }
    return tree;
}
unsafe extern "C" fn ts_subtree__write_char_to_string(mut s:
                                                          *mut libc::c_char,
                                                      mut n: size_t,
                                                      mut c: int32_t)
 -> size_t {
    if c == -(1 as libc::c_int) {
        return snprintf(s, n,
                        b"INVALID\x00" as *const u8 as *const libc::c_char) as
                   size_t
    } else if c == '\u{0}' as i32 {
        return snprintf(s, n,
                        b"\'\\0\'\x00" as *const u8 as *const libc::c_char) as
                   size_t
    } else if c == '\n' as i32 {
        return snprintf(s, n,
                        b"\'\\n\'\x00" as *const u8 as *const libc::c_char) as
                   size_t
    } else if c == '\t' as i32 {
        return snprintf(s, n,
                        b"\'\\t\'\x00" as *const u8 as *const libc::c_char) as
                   size_t
    } else if c == '\r' as i32 {
        return snprintf(s, n,
                        b"\'\\r\'\x00" as *const u8 as *const libc::c_char) as
                   size_t
    } else if (0 as libc::c_int) < c && c < 128 as libc::c_int &&
                  *(*__ctype_b_loc()).offset(c as isize) as libc::c_int &
                      _ISprint as libc::c_int as libc::c_ushort as libc::c_int
                      != 0 {
        return snprintf(s, n,
                        b"\'%c\'\x00" as *const u8 as *const libc::c_char, c)
                   as size_t
    } else {
        return snprintf(s, n, b"%d\x00" as *const u8 as *const libc::c_char,
                        c) as size_t
    };
}
unsafe extern "C" fn ts_subtree__write_dot_string(mut f: *mut FILE,
                                                  mut string:
                                                      *const libc::c_char) {
    let mut c: *const libc::c_char = string;
    while *c != 0 {
        if *c as libc::c_int == '\"' as i32 {
            fputs(b"\\\"\x00" as *const u8 as *const libc::c_char, f);
        } else if *c as libc::c_int == '\n' as i32 {
            fputs(b"\\n\x00" as *const u8 as *const libc::c_char, f);
        } else { fputc(*c as libc::c_int, f); }
        c = c.offset(1)
    };
}
static mut ROOT_FIELD: *const libc::c_char =
    b"__ROOT__\x00" as *const u8 as *const libc::c_char;
unsafe extern "C" fn ts_subtree__write_to_string(mut self_0: Subtree,
                                                 mut string:
                                                     *mut libc::c_char,
                                                 mut limit: size_t,
                                                 mut language:
                                                     *const TSLanguage,
                                                 mut include_all: bool,
                                                 mut alias_symbol: TSSymbol,
                                                 mut alias_is_named: bool,
                                                 mut field_name:
                                                     *const libc::c_char)
 -> size_t {
    if self_0.ptr.is_null() {
        return snprintf(string, limit,
                        b"(NULL)\x00" as *const u8 as *const libc::c_char) as
                   size_t
    }
    let mut cursor: *mut libc::c_char = string;
    let mut writer: *mut *mut libc::c_char =
        if limit > 0 as libc::c_int as libc::c_ulong {
            &mut cursor
        } else { &mut string };
    let mut is_root: bool = field_name == ROOT_FIELD;
    let mut is_visible: bool =
        include_all as libc::c_int != 0 ||
            ts_subtree_missing(self_0) as libc::c_int != 0 ||
            (if alias_symbol as libc::c_int != 0 {
                 alias_is_named as libc::c_int
             } else {
                 (ts_subtree_visible(self_0) as libc::c_int != 0 &&
                      ts_subtree_named(self_0) as libc::c_int != 0) as
                     libc::c_int
             }) != 0;
    if is_visible {
        if !is_root {
            cursor =
                cursor.offset(snprintf(*writer, limit,
                                       b" \x00" as *const u8 as
                                           *const libc::c_char) as isize);
            if !field_name.is_null() {
                cursor =
                    cursor.offset(snprintf(*writer, limit,
                                           b"%s: \x00" as *const u8 as
                                               *const libc::c_char,
                                           field_name) as isize)
            }
        }
        if ts_subtree_is_error(self_0) as libc::c_int != 0 &&
               ts_subtree_child_count(self_0) ==
                   0 as libc::c_int as libc::c_uint &&
               (*self_0.ptr).size.bytes > 0 as libc::c_int as libc::c_uint {
            cursor =
                cursor.offset(snprintf(*writer, limit,
                                       b"(UNEXPECTED \x00" as *const u8 as
                                           *const libc::c_char) as isize);
            cursor =
                cursor.offset(ts_subtree__write_char_to_string(*writer, limit,
                                                               (*self_0.ptr).c2rust_unnamed.lookahead_char)
                                  as isize)
        } else {
            let mut symbol: TSSymbol =
                if alias_symbol as libc::c_int != 0 {
                    alias_symbol as libc::c_int
                } else { ts_subtree_symbol(self_0) as libc::c_int } as
                    TSSymbol;
            let mut symbol_name: *const libc::c_char =
                ts_language_symbol_name(language, symbol);
            if ts_subtree_missing(self_0) {
                cursor =
                    cursor.offset(snprintf(*writer, limit,
                                           b"(MISSING \x00" as *const u8 as
                                               *const libc::c_char) as isize);
                if alias_is_named as libc::c_int != 0 ||
                       ts_subtree_named(self_0) as libc::c_int != 0 {
                    cursor =
                        cursor.offset(snprintf(*writer, limit,
                                               b"%s\x00" as *const u8 as
                                                   *const libc::c_char,
                                               symbol_name) as isize)
                } else {
                    cursor =
                        cursor.offset(snprintf(*writer, limit,
                                               b"\"%s\"\x00" as *const u8 as
                                                   *const libc::c_char,
                                               symbol_name) as isize)
                }
            } else {
                cursor =
                    cursor.offset(snprintf(*writer, limit,
                                           b"(%s\x00" as *const u8 as
                                               *const libc::c_char,
                                           symbol_name) as isize)
            }
        }
    } else if is_root {
        let mut symbol_0: TSSymbol = ts_subtree_symbol(self_0);
        let mut symbol_name_0: *const libc::c_char =
            ts_language_symbol_name(language, symbol_0);
        cursor =
            cursor.offset(snprintf(*writer, limit,
                                   b"(\"%s\")\x00" as *const u8 as
                                       *const libc::c_char, symbol_name_0) as
                              isize)
    }
    if ts_subtree_child_count(self_0) != 0 {
        let mut alias_sequence: *const TSSymbol =
            ts_language_alias_sequence(language,
                                       (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.production_id
                                           as uint32_t);
        let mut field_map: *const TSFieldMapEntry =
            0 as *const TSFieldMapEntry;
        let mut field_map_end: *const TSFieldMapEntry =
            0 as *const TSFieldMapEntry;
        ts_language_field_map(language,
                              (*self_0.ptr).c2rust_unnamed.c2rust_unnamed.production_id
                                  as uint32_t, &mut field_map,
                              &mut field_map_end);
        let mut structural_child_index: uint32_t =
            0 as libc::c_int as uint32_t;
        let mut i: uint32_t = 0 as libc::c_int as uint32_t;
        while i < (*self_0.ptr).child_count {
            let mut child: Subtree =
                *(*self_0.ptr).c2rust_unnamed.c2rust_unnamed.children.offset(i
                                                                                 as
                                                                                 isize);
            if ts_subtree_extra(child) {
                cursor =
                    cursor.offset(ts_subtree__write_to_string(child, *writer,
                                                              limit, language,
                                                              include_all,
                                                              0 as libc::c_int
                                                                  as TSSymbol,
                                                              0 as libc::c_int
                                                                  != 0,
                                                              0 as
                                                                  *const libc::c_char)
                                      as isize)
            } else {
                let mut alias_symbol_0: TSSymbol =
                    if !alias_sequence.is_null() {
                        *alias_sequence.offset(structural_child_index as
                                                   isize) as libc::c_int
                    } else { 0 as libc::c_int } as TSSymbol;
                let mut alias_is_named_0: bool =
                    if alias_symbol_0 as libc::c_int != 0 {
                        ts_language_symbol_metadata(language,
                                                    alias_symbol_0).named() as
                            libc::c_int
                    } else { 0 as libc::c_int } != 0;
                let mut child_field_name: *const libc::c_char =
                    if is_visible as libc::c_int != 0 {
                        0 as *const libc::c_char
                    } else { field_name };
                let mut i_0: *const TSFieldMapEntry = field_map;
                while i_0 < field_map_end {
                    if !(*i_0).inherited &&
                           (*i_0).child_index as libc::c_uint ==
                               structural_child_index {
                        child_field_name =
                            *(*language).field_names.offset((*i_0).field_id as
                                                                isize);
                        break ;
                    } else { i_0 = i_0.offset(1) }
                }
                cursor =
                    cursor.offset(ts_subtree__write_to_string(child, *writer,
                                                              limit, language,
                                                              include_all,
                                                              alias_symbol_0,
                                                              alias_is_named_0,
                                                              child_field_name)
                                      as isize);
                structural_child_index =
                    structural_child_index.wrapping_add(1)
            }
            i = i.wrapping_add(1)
        }
    }
    if is_visible {
        cursor =
            cursor.offset(snprintf(*writer, limit,
                                   b")\x00" as *const u8 as
                                       *const libc::c_char) as isize)
    }
    return cursor.wrapping_offset_from(string) as libc::c_long as size_t;
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_string(mut self_0: Subtree,
                                           mut language: *const TSLanguage,
                                           mut include_all: bool)
 -> *mut libc::c_char {
    let mut scratch_string: [libc::c_char; 1] = [0; 1];
    let mut size: size_t =
        ts_subtree__write_to_string(self_0, scratch_string.as_mut_ptr(),
                                    0 as libc::c_int as size_t, language,
                                    include_all, 0 as libc::c_int as TSSymbol,
                                    0 as libc::c_int != 0,
                                    ROOT_FIELD).wrapping_add(1 as libc::c_int
                                                                 as
                                                                 libc::c_ulong);
    let mut result: *mut libc::c_char =
        malloc(size.wrapping_mul(::std::mem::size_of::<libc::c_char>() as
                                     libc::c_ulong)) as *mut libc::c_char;
    ts_subtree__write_to_string(self_0, result, size, language, include_all,
                                0 as libc::c_int as TSSymbol,
                                0 as libc::c_int != 0, ROOT_FIELD);
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree__print_dot_graph(mut self_0:
                                                         *const Subtree,
                                                     mut start_offset:
                                                         uint32_t,
                                                     mut language:
                                                         *const TSLanguage,
                                                     mut alias_symbol:
                                                         TSSymbol,
                                                     mut f: *mut FILE) {
    let mut subtree_symbol: TSSymbol = ts_subtree_symbol(*self_0);
    let mut symbol: TSSymbol =
        if alias_symbol as libc::c_int != 0 {
            alias_symbol as libc::c_int
        } else { subtree_symbol as libc::c_int } as TSSymbol;
    let mut end_offset: uint32_t =
        start_offset.wrapping_add(ts_subtree_total_bytes(*self_0));
    fprintf(f, b"tree_%p [label=\"\x00" as *const u8 as *const libc::c_char,
            self_0);
    ts_subtree__write_dot_string(f,
                                 ts_language_symbol_name(language, symbol));
    fprintf(f, b"\"\x00" as *const u8 as *const libc::c_char);
    if ts_subtree_child_count(*self_0) == 0 as libc::c_int as libc::c_uint {
        fprintf(f,
                b", shape=plaintext\x00" as *const u8 as *const libc::c_char);
    }
    if ts_subtree_extra(*self_0) {
        fprintf(f,
                b", fontcolor=gray\x00" as *const u8 as *const libc::c_char);
    }
    fprintf(f,
            b", tooltip=\"range: %u - %u\nstate: %d\nerror-cost: %u\nhas-changes: %u\nrepeat-depth: %u\nlookahead-bytes: %u\x00"
                as *const u8 as *const libc::c_char, start_offset, end_offset,
            ts_subtree_parse_state(*self_0) as libc::c_int,
            ts_subtree_error_cost(*self_0),
            ts_subtree_has_changes(*self_0) as libc::c_int,
            ts_subtree_repeat_depth(*self_0),
            ts_subtree_lookahead_bytes(*self_0));
    if ts_subtree_is_error(*self_0) as libc::c_int != 0 &&
           ts_subtree_child_count(*self_0) == 0 as libc::c_int as libc::c_uint
       {
        fprintf(f,
                b"\ncharacter: \'%c\'\x00" as *const u8 as
                    *const libc::c_char,
                (*(*self_0).ptr).c2rust_unnamed.lookahead_char);
    }
    fprintf(f, b"\"]\n\x00" as *const u8 as *const libc::c_char);
    let mut child_start_offset: uint32_t = start_offset;
    let mut child_info_offset: uint32_t =
        ((*language).max_alias_sequence_length as libc::c_int *
             ts_subtree_production_id(*self_0) as libc::c_int) as uint32_t;
    let mut i: uint32_t = 0 as libc::c_int as uint32_t;
    let mut n: uint32_t = ts_subtree_child_count(*self_0);
    while i < n {
        let mut child: *const Subtree =
            &mut *(*(*self_0).ptr).c2rust_unnamed.c2rust_unnamed.children.offset(i
                                                                                     as
                                                                                     isize)
                as *mut Subtree;
        let mut alias_symbol_0: TSSymbol = 0 as libc::c_int as TSSymbol;
        if !ts_subtree_extra(*child) && child_info_offset != 0 {
            alias_symbol_0 =
                *(*language).alias_sequences.offset(child_info_offset as
                                                        isize);
            child_info_offset = child_info_offset.wrapping_add(1)
        }
        ts_subtree__print_dot_graph(child, child_start_offset, language,
                                    alias_symbol_0, f);
        fprintf(f,
                b"tree_%p -> tree_%p [tooltip=%u]\n\x00" as *const u8 as
                    *const libc::c_char, self_0, child, i);
        child_start_offset =
            (child_start_offset as
                 libc::c_uint).wrapping_add(ts_subtree_total_bytes(*child)) as
                uint32_t as uint32_t;
        i = i.wrapping_add(1)
    };
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_print_dot_graph(mut self_0: Subtree,
                                                    mut language:
                                                        *const TSLanguage,
                                                    mut f: *mut FILE) {
    fprintf(f, b"digraph tree {\n\x00" as *const u8 as *const libc::c_char);
    fprintf(f,
            b"edge [arrowhead=none]\n\x00" as *const u8 as
                *const libc::c_char);
    ts_subtree__print_dot_graph(&mut self_0, 0 as libc::c_int as uint32_t,
                                language, 0 as libc::c_int as TSSymbol, f);
    fprintf(f, b"}\n\x00" as *const u8 as *const libc::c_char);
}
#[no_mangle]
pub unsafe extern "C" fn ts_subtree_external_scanner_state_eq(mut self_0:
                                                                  Subtree,
                                                              mut other:
                                                                  Subtree)
 -> bool {
    let mut state1: *const ExternalScannerState = &empty_state;
    let mut state2: *const ExternalScannerState = &empty_state;
    if !self_0.ptr.is_null() &&
           ts_subtree_has_external_tokens(self_0) as libc::c_int != 0 &&
           (*self_0.ptr).child_count == 0 {
        state1 = &(*self_0.ptr).c2rust_unnamed.external_scanner_state
    }
    if !other.ptr.is_null() &&
           ts_subtree_has_external_tokens(other) as libc::c_int != 0 &&
           (*other.ptr).child_count == 0 {
        state2 = &(*other.ptr).c2rust_unnamed.external_scanner_state
    }
    return ts_external_scanner_state_eq(state1, state2);
}
